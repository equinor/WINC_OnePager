{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Wellbore Pressure calculation","text":""},{"location":"#introduction","title":"Introduction","text":"<p>WINC_OnePager provides analytical wellbore pressure estimation tools for assessing CO2 leakage risk through abandoned wells. This project was initially developed as part of the SCREEN project, but the analytical pressure estimation module has been developed and maintained as a separate, standalone entity.</p> <p>The toolbox provides a series of script-based tools to assist risk assessment of legacy wells by computing pressure gradients and visualizing well construction data.</p> <p>The toolbox can be grouped in two main modules: A pre-processing and preliminary assessment, and a detailed simulation workflow as shown in the figure below.</p> <p></p>"},{"location":"#pre-processing-and-preliminary-assesment","title":"Pre-processing and preliminary assesment","text":""},{"location":"#data-preparation","title":"Data Preparation","text":"<p>The first step in using the WINC_OnePager toolbox is to gather all the necessary data. Sources of data include both subsurface data nearby well and specifics about the well construction. Some of this data can ba gathered from internal databases, but some other has to be retrieved manually. Whichever the method, the current solution requires the data to be collected on an input sheet (CSV or YAML file) with tables containing different datasets.</p> <p>To collect the data these are some steps that can be followed:</p> <p>\u2022   Identify the required data: Review the list of required tables and columns in the input data file to determine what information you need to gather. This includes well header information, drilling intervals, casing and cementing intervals, barriers, geological units, and assumptions (see table below).</p> <p>\u2022   Collect the data: Involve both subsurface and well integrity experts involved on the project to provide curated datasets to be used in the evaluation. By doing this, we ensure data has been previously verified. Subsurface data can vary from simple well tops, temperature profiles to more specifics about the quality of the reservoirs involved, potential flow units in the overburden, and the current state of reservoir pressure in case it deviates from hydrostatic. A previous qualitative leakage risk assessment of the wells shall provide the necessary input relevant for the well.</p> <p>\u2022   Organize the data: Organize the data into tables according to the structure of the input data file. Use a spreadsheet program or a text editor to create a CSV file with multiple tables, each separated by a blank line. Ensure that all required tables and columns are included in the input data file and that the data is entered correctly.</p> <p>\u2022   Include assumptions: The assumptions depend on the stage of knowledge of the area. If there is a reservoir model in place, such model should be used to fill in the information for these tables. Otherwise, these should be discussed with the subsurface personnel involved in the project.</p> <p>The input sheet could be defined as aither a YAML or a CSV file. It shall include the following tables:</p> Category Item Property Source Sketch Simulation Well Well header well name well reports   / database :heavy_check_mark: :heavy_check_mark: Well Well header well RKB well reports   / database :heavy_check_mark: :heavy_check_mark: Well Well header well td well reports   / database :heavy_check_mark: :heavy_check_mark: Well Well header water depth /   mudline depth well reports   / database :heavy_check_mark: :heavy_check_mark: Well Bitsize records Top and   bottom depth (MD RKB), diameter well reports :heavy_check_mark: :heavy_check_mark: Well Bitsize records Permeability* assumed :x: :heavy_check_mark: Well Casings Top and   bottom depth (MD RKB), diameter well reports :heavy_check_mark: :heavy_check_mark: Well Casings Permeability* assumed :x: :heavy_check_mark: Well Cement bond Min, max and   most likely top and bottom depth well   assesment :heavy_check_mark: :heavy_check_mark: Well Cement bond Permeability* assumed /   well assesment :x: :heavy_check_mark: Well Barriers/cement plugs Min, max and   most likely top and bottom depth well   assesment :heavy_check_mark: :heavy_check_mark: Well Barriers/cement plugs Permeability* assumed /   well assesment :x: :heavy_check_mark: Subsurface Geological tops Top depth (MD   RKB) well reports   / database :heavy_check_mark: :heavy_check_mark: Subsurface Geological tops Transport   properties (porosity, permeability)** assumed    / asset :heavy_check_mark: :heavy_check_mark: Subsurface Geothermal info Seafloor   temperature assumed    / asset :heavy_check_mark: :heavy_check_mark: Subsurface Geothermal info Temperature   survey (if available) assumed    / asset :heavy_check_mark: :heavy_check_mark: Subsurface Geothermal info Geothermal   gradient assumed    / asset :heavy_check_mark: :heavy_check_mark: Subsurface Initialization Reservoir   pressure (scenarios) asset :heavy_check_mark: :heavy_check_mark: Subsurface Initialization Base of CO2   (CO2-water contact depth) asset :heavy_check_mark: :heavy_check_mark: <p>permeability can be declared as good, average, poor *flow units declaration</p>"},{"location":"#data-visualization-and-proxy-based-leakage-estimation","title":"Data Visualization and Proxy-based Leakage Estimation","text":"<p>Once all the information is tabulated, it can be processed with a python script. The processing will store the data in memory and use it to produce a hybrid geological well-sketch and a pressure-depth plot displaying the fluid pressures of each phase and the minimum horizontal stress.</p> <p>The well sketch combines both subsurface data and well engineering information. It serves as a starting point to identify the main leakage pathways and illustrate the main risks associated with the well.</p> <p>The pressure plot, besides visualizing the provided pressure scenarios, has the necessary input to run a preliminary leakage estimation based on a Darcy-based proxy. This proxy gives an estimate of leakage rates through the main barrier (deepest cement plug). The magnitude will be a function of both the transport properties assigned to the barrier and the resulting phase pressures of each scenario.</p> <p></p>"},{"location":"#detailed-simulation-workflow","title":"Detailed simulation workflow","text":"<p>For wells with larger uncertainties and more complex leakage pathways, a simulation-based approach can assist in generating a more accurate estimate of leakage.</p> <p>By fulfilling the first two modules, the data is ready to be processed through a second script that generates and initializes a simple reservoir model with a finite-volume representation of the legacy well.</p>"},{"location":"#building-the-mesh","title":"Building the mesh","text":"<p>The generated mesh is a coarse mesh with <code>local grid refinement (LGR)</code> in the middle. The higher resolution of the LGR is used to represent well construction details.</p> <p>Due to the cartesian nature of the mesh, the cylindrical shape of the well is turned into a prism. A horizontal cross-section of the well in the LGR is square, with sides meant to preserve the area of the original circle. However, discrepancies between volumes may occur due to mesh resolution.</p> <p>The transport properties of geological units are inherited from coarse grid and updated to represent well. Open borehole is represented by high permeability grid cells. Cement plugs and cement-bond are represented by low permeability cells. Casing is represented by reduction of transmissibility of cell interfaces.</p>"},{"location":"#running-the-simulation","title":"Running the simulation","text":""},{"location":"#exploring-the-simulation-output","title":"Exploring the simulation output","text":""},{"location":"INSTALLATION/","title":"WINC_OnePager","text":"<p>This repository contains source codes and documentation for the WINC_OnePager project - an analytical wellbore pressure estimation tool for CO2 leakage risk assessment through abandoned wells.</p> <p>Note: This project was initially developed as part of the SCREEN project, but the analytical pressure estimation module has been developed and maintained as a separate, standalone entity.</p> <p> </p>"},{"location":"INSTALLATION/#installation-instructions","title":"Installation Instructions","text":""},{"location":"INSTALLATION/#prerequisites-python-installation","title":"Prerequisites: Python Installation","text":"<p>This code has been tested with Python versions 3.9 through 3.12. The recommended way to install and manage Python is using uv.</p> <p>Equinor users: Please follow the internal guidelines available at: https://wiki.equinor.com/wiki/Using_Python_on_Windows_11_with_uv</p> <p>For Windows users, install uv using winget:</p> <pre><code>winget install --id=astral-sh.uv -e</code></pre> <p>For Linux/macOS users:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh</code></pre> <p>Once uv is installed, reload your terminal and install Python:</p> <pre><code>uv python install 3.12</code></pre> <p>For other installation methods, see the uv installation docs.</p>"},{"location":"INSTALLATION/#clone-and-install","title":"Clone and Install","text":"<pre><code>git clone https://github.com/equinor/WINC_OnePager\ncd WINC_OnePager\nuv sync</code></pre> <p>This will create a virtual environment and install all dependencies including dev, docs, test, and dash groups.</p>"},{"location":"INSTALLATION/#run-commands","title":"Run Commands","text":"<p>Use <code>uv run</code> to execute commands in the project environment:</p> <pre><code>uv run python -m experiments.well_sketch_pressure --config-file ./test_data/examples/wildcat/wildcat.yaml</code></pre> <p>Or activate the environment:</p> <pre><code>source .venv/bin/activate  # Linux/macOS\n# or\n.venv\\Scripts\\activate     # Windows</code></pre>"},{"location":"INSTALLATION/#with-pip","title":"With pip","text":"<p>You can also install using pip in a virtual environment:</p>"},{"location":"INSTALLATION/#1-create-and-activate-a-virtual-environment","title":"1. Create and Activate a Virtual Environment","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate  # Linux/macOS\n# or\n.venv\\Scripts\\activate     # Windows</code></pre>"},{"location":"INSTALLATION/#2-install-the-project","title":"2. Install the Project","text":"<pre><code>pip install .</code></pre> <p>Or install with development dependencies:</p> <pre><code>pip install -e \".[dev,docs,test]\"</code></pre>"},{"location":"INSTALLATION/#experiments","title":"Experiments","text":"<p>There are at least two ways to make experimenal runs of the codes. One is to run the experiments with Jupyter lab (notbeooks folder), and the other is commandline option. While Jupyter notebooks are mainly for QC tests and research purposes, the commandline option is aiming for production run.</p>"},{"location":"INSTALLATION/#1-jupyter-notebooks","title":"1. Jupyter notebooks","text":"<p>Jupyter notebooks are located in directory <code>notebooks</code>. To test its functionaries, change current directory to <code>notebooks</code> and launch jupyter notebooks at the commandline: <pre><code>jupyter-lab</code></pre> Or if you prefer, you can run these Jupyter notebooks from Microsoft's VS code.</p> <p>There exist several Jupyter notebooks in the directory:</p> <ul> <li>Notebook Pressure-WellClass.ipynb is used to test pressure. </li> <li>Notebook WellClass_csv_yaml.ipynb is used to test pressure and loading <code>.csv</code> and <code>.yaml</code> input files.</li> </ul>"},{"location":"INSTALLATION/#2-commandline-option","title":"2. Commandline option","text":"<p>Two python scripts for commandline option are available in directory <code>experiments</code>. One script, well_sketch.py, can be used for generating a well sketch, well_sketch_pressure.py can be used for generating both a well sketch and a pressure plot. </p> <p>The followings are some of  the sample runs. In either way, you should run the python script inside the <code>WINC_OnePager</code> directory. </p> <ol> <li>To test well_sketch_pressure.py, run either of the followings: <pre><code># for smeaheia_v1\nuv run python -m experiments.well_sketch_pressure --config-file ./test_data/examples/smeaheia_v1/smeaheia.yaml\n\n# for wildcat\nuv run python -m experiments.well_sketch_pressure --config-file ./test_data/examples/wildcat/wildcat.yaml</code></pre></li> </ol>"},{"location":"INSTALLATION/#3-test-data","title":"3. Test data","text":"<p>In order for a quick test of the codes, we include some test dataset in the folder <code>test_data/examples</code>. </p> <p><pre><code>\u251c\u2500\u2500 frigg\n\u2502   \u251c\u2500\u2500 GaP_input_Frigg_v3.csv\n\u2502   \u2514\u2500\u2500 X_5687dev.txt\n\u251c\u2500\u2500 simple_well\n\u2502   \u251c\u2500\u2500 Simple_well.csv\n\u2502   \u2514\u2500\u2500 Simple_well.yaml\n\u251c\u2500\u2500 smeaheia_v1\n\u2502   \u251c\u2500\u2500 GaP_input_Smeaheia_v3.csv\n\u2502   \u2514\u2500\u2500 smeaheia.yaml\n\u251c\u2500\u2500 wildcat\n    \u251c\u2500\u2500 GaP_input_Wildcat_v3.csv\n    \u2514\u2500\u2500 wildcat.yaml\n\n\n## Unit testing and code coverage\nWe are using `pytest` for unit testing and code coverage. The unit testing utilizes `wildcat` as the testing example. So please make sure the saved .pkl files in ```test_data/examples/wildcat/pytest``` exists and is updated. Here is a commandline example:\n```shell\nuv run pytest tests</code></pre> This will report the unit testing results. And the following will report not only unit testing but also code coverage: <pre><code>uv run pytest --cov tests</code></pre> or a little bit more complex command: <pre><code>uv run pytest --cov --cov-branch --cov-report term-missing tests</code></pre></p>"},{"location":"INSTALLATION/#documentation","title":"Documentation","text":"<p>The documentation can be automatically generated and deployed to GitHub Pages. To do that, type the following at the command line: <pre><code>uv run mkdocs gh-deploy</code></pre> It may take some minutes until the documentation goes live. And the generated documentation page can be found at WINC_OnePager docs.</p>"},{"location":"INSTALLATION/#the-code-structures","title":"The code structures","text":"<p>The following represents the current code structures:</p> <pre><code>.\n\u251c\u2500\u2500 CITATION.cff\n\u251c\u2500\u2500 experiments\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 well_pressure_tables.py\n\u2502   \u251c\u2500\u2500 well_sketch_pressure.py\n\u2502   \u2514\u2500\u2500 well_sketch.py\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 notebooks\n\u2502   \u251c\u2500\u2500 Pressure-WellClass.ipynb\n\u2502   \u251c\u2500\u2500 PVT_data.ipynb\n\u2502   \u251c\u2500\u2500 WellClass_csv_yaml.ipynb\n\u2502   \u2514\u2500\u2500 WellClass-onepager.ipynb\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 requirements.txt.frozen\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 WellClass\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 libs\n\u2502       \u251c\u2500\u2500 notebooks\n\u2502       \u251c\u2500\u2500 README.md\n\u2502       \u2514\u2500\u2500 tools\n\u251c\u2500\u2500 test_data\n\u2502   \u2514\u2500\u2500 examples\n\u2502       \u251c\u2500\u2500 frigg\n\u2502       \u251c\u2500\u2500 simple_well\n\u2502       \u251c\u2500\u2500 smeaheia_v1\n\u2502       \u251c\u2500\u2500 wildcat\n\u2502       \u251c\u2500\u2500 wildcat-pflotran\n\u2502       \u2514\u2500\u2500 wildcat-pflotran-2\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 conftest.py\n    \u2514\u2500\u2500 well_class\n        \u2514\u2500\u2500 test_well_class.py</code></pre> <p>It was generated with the linux command <code>tree</code>: <pre><code>tree -I 'docs|site|venv_screen|*pycache*|Equinor*|originals' -L 3</code></pre></p>"},{"location":"mkdocs/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"mkdocs/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs gh-deploy</code> - Deploy the documentation to GitHub page (<code>gh-pages</code> branch)</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"mkdocs/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.</code></pre>"},{"location":"well_class/","title":"WELL CLASS for pre-processing well data","text":""},{"location":"well_class/#data-preparation","title":"Data Preparation","text":"<p>The first step in using the WINC_OnePager toolbox is to gather all the necessary data to build a plugged and abandoned well sketch, along with any relevant subsurface data surrounding the well. This data should be prepared in a CSV file with multiple tables, each separated by a blank line.</p> <p>To collect the data these are some steps that can be followed:</p> <ul> <li> <p>Identify the required data: Review the list of required tables and columns in the input data file to determine what information you need to gather. This includes well header information, drilling intervals, casing and cementing intervals, barriers, geological units, and assumptions.</p> </li> <li> <p>Collect the data: Gather the necessary data from various sources. The information in the first tables should be available from the final well reports. Retrieving the data may involve manually scouting numbers in the reports that could be presented in different places and different formats. Other databases can be referred to retrieve temperature data or updated geological well tops.</p> </li> <li> <p>Verify the data: Check the accuracy and completeness of the data by cross-referencing it with multiple sources and verifying it with domain experts. Ensure that all required tables and columns are included in the input data file and that the data is entered correctly.</p> </li> <li> <p>Organize the data: Organize the data into tables according to the structure of the input data file. Use a spreadsheet program or a text editor to create a CSV file with multiple tables, each separated by a blank line.</p> </li> <li> <p>Include assumptions: The assumptions depend on the stage of knowledge of the area. If there is a reservoir model in place, this should be used to fill in the information for these tables. Otherwise these should discussed with the subsurface personnel involved in the project.</p> </li> </ul> <p>The CSV file shall include the following tables:</p> <ul> <li> <p><code>well_header</code>: This table contains general information about the well, such as its name (well_name), RKB elevation (well_rkb), depth of the sea floor (sf_depth_msl), total depth (well_td_rkb), sea floor temperature (sf_temp), and geothermal gradient (geo_tgrad).</p> </li> <li> <p><code>drilling</code>: This table contains information about the drilling intervals of the well, including the top and bottom depths in RKB (top_rkb, bottom_rkb) and the diameter of the borehole in inches (diameter_in).</p> </li> <li> <p><code>casing_cement</code>: This table contains information about the casing and cementing intervals of the well, including the top and bottom depths in RKB (top_rkb, bottom_rkb), diameter of the casing in inches (diameter_in), top  and bottom of cement-bond in RKB (toc_rkb, boc_rkb), and whether or not it has a shoe (shoe).</p> </li> <li> <p><code>barriers</code>: This table lists the barriers in the well along with their name (barrier_name), type (barrier_type), and top and bottom depths in RKB (top_rkb, bottom_rkb).</p> </li> <li> <p><code>geology</code>: This table lists the geological units encountered in the well along with their top depth in RKB (top_rkb), name (geol_unit), and whether or not they are considered a reservoir (reservoir_flag).</p> </li> <li> <p><code>assumptions</code>: This section includes several tables with information about assumptions used in the analysis, such as reservoir pressure scenarios (reservoir_pressure), CO2 datum depth (co2_datum), main barrier name (main_barrier), and barrier permeability values for different quality levels (barrier_permeability).</p> </li> </ul> <p>Here is an example of how the CSV file could be structured, along with explanations for each table:</p> <pre><code>input_data\n\nwell_header\nwell_name,wellA\nwell_rkb,30\nsf_depth_msl,105\nwell_td_rkb,3997\nsf_temp,4\ngeo_tgrad,40\n\ndrilling\ntop_rkb,bottom_rkb,diameter_in\n132,190,36\n190,444,26\n444,1812,17 1/2\n1812,3942,12 1/4\n3942,3997,8 1/2\n\ncasing_cement\ntop_rkb,bottom_rkb,diameter_in,toc_rkb,boc_rkb,shoe\n132,158,30,132,158,TRUE\n132,439,20,132,439,TRUE\n182,1803,13 3/8,450,1803,TRUE\n\nbarriers\nbarrier_name,barrier_type,top_rkb,bottom_rkb\ncement plug #3,cplug,132,150\ncement plug #2,cplug,1690,1850\ncement plug #1,cplug,2050,2300\n\ngeology\ntop_rkb,geol_unit,reservoir_flag\n132,OVERBURDEN,FALSE\n2122,CAP ROCK,FALSE\n2265,RESERVOIR,TRUE\n\nassumptions\n\nreservoir_pressure\ndepth_msl,RP1,RP2\n2238,90 110\n\nco2_datum\nco2_msl,2370\n\nmain_barrier\nbarrier_name,cplug2\n\nbarrier_permeability\nquality,kv\ngood,0.01\nmid,10\npoor,1.00E+03</code></pre>"},{"location":"well_class/#data-visualization-and-proxy-based-leakage-estimation","title":"Data Visualization and Proxy-based Leakage Estimation","text":"<p>Once all the information is tabulated, it can be processed through the well class. </p> <pre><code>#Import CSV tables\nfilename = r'csv_file.csv'\n\nwell_csv = csv_parser(filename)\n\n#Process well by running well class\nmy_well = Well( header       = well_csv['well_header'], \n                drilling     = well_csv['drilling'],\n                casings      = well_csv['casing_cement'],\n                barriers     = well_csv['barriers'], \n                reservoir_P  = well_csv['reservoir_pressure'],\n                main_barrier = well_csv['main_barrier'],\n                barrier_perm = well_csv['barrier_permeability'],\n                co2_datum    = well_csv['co2_datum'],\n                geology      = well_csv['geology'],\n           )</code></pre> <p>The processing will store the data in memory and use it to produce a hybrid geological well-sketch and a pressure-depth plot displaying the fluid pressures of each phase and the minimum horizontal stress.</p> <pre><code>#Plot sketch, pressures\nfig, (ax1, ax2) = plt.subplots(1,2, sharey=True)\nmy_well.plot_sketch(ax=ax1)\nmy_well.plot_pressure(ax=ax2)\n\nfig.tight_layout()\n</code></pre> <p>The well sketch combines both subsurface data and well engineering information. It serves as a starting point to identify the main leakage pathways and illustrate the main risks associated with the well.</p> <p>The pressure plot, besides visualizing the provided pressure scenarios, has the necessary input to run a preliminary leakage estimation based on a Darcy-based proxy. This proxy gives an estimate of leakage rates through the main barrier (deepest cement plug). The magnitude will be a function of both the transport properties assigned to the barrier and the resulting phase pressures of each scenario.</p> <p></p>"},{"location":"code_references/well_class/models/","title":"Models","text":""},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils","title":"<code>src.WellClass.libs.models.well_model_utils</code>","text":""},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.WellHeaderModel","title":"<code>WellHeaderModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>General information about the well.</p> <p>Parameters:</p> <ul> <li> <code>well_name</code>               (<code>str</code>)           \u2013            <p>well name</p> </li> <li> <code>well_rkb</code>               (<code>float</code>)           \u2013            <p>RKB elevation</p> </li> <li> <code>sf_depth_msl</code>               (<code>float</code>)           \u2013            <p>depth of the sea floor</p> </li> <li> <code>well_td_rkb</code>               (<code>float</code>)           \u2013            <p>total depth of RKB</p> </li> <li> <code>sf_temp</code>               (<code>float</code>)           \u2013            <p>sea floor temperature</p> </li> <li> <code>geo_tgrad</code>               (<code>float</code>)           \u2013            <p>geothermal gradient</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class WellHeaderModel(BaseModel):\n    \"\"\" General information about the well.\n\n        Args:\n            well_name (str): well name\n            well_rkb (float): RKB elevation\n            sf_depth_msl (float): depth of the sea floor\n            well_td_rkb (float): total depth of RKB\n            sf_temp (float): sea floor temperature\n            geo_tgrad  (float): geothermal gradient\n    \"\"\"\n    well_name: str\n    well_rkb: Union[int, float]\n    sf_depth_msl: Union[int, float]\n    well_td_rkb: Union[int, float]\n    sf_temp: Union[int, float]\n    geo_tgrad: Union[int, float]</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.DrillingRawModel","title":"<code>DrillingRawModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Information about the drilling intervals of the well</p> <p>Parameters:</p> <ul> <li> <code>top_rkb</code>               (<code>float</code>)           \u2013            <p>the top depth in RKB</p> </li> <li> <code>bottom_rkb</code>               (<code>float</code>)           \u2013            <p>the bottom depth in RKB </p> </li> <li> <code>diameter_in</code>               (<code>(float, str)</code>)           \u2013            <p>the diameter of the borehole in inches</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class DrillingRawModel(BaseModel):\n    \"\"\" Information about the drilling intervals of the well\n\n        Args:\n            top_rkb (float): the top depth in RKB\n            bottom_rkb (float): the bottom depth in RKB \n            diameter_in (float, str): the diameter of the borehole in inches\n    \"\"\"\n    top_rkb: Union[int, float]\n    bottom_rkb: Union[int, float]\n    diameter_in: Union[float, int, str]\n\n    @field_validator('diameter_in')\n    def diameter_in_converter(cls, v):\n        if isinstance(v, (float, int)):\n            return v\n        elif isinstance(v, str):\n            return fraction_float(v)\n        else:\n            raise ValueError('diameter_in must be a float or string')</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.DrillingModel","title":"<code>DrillingModel</code>","text":"<p>               Bases: <code>DrillingRawModel</code></p> <p>Information about the drilling intervals of the well</p> <p>Parameters:</p> <ul> <li> <code>oh_perm</code>               (<code>float</code>)           \u2013            <p>faked permeability for open-hole</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class DrillingModel(DrillingRawModel):\n    \"\"\" Information about the drilling intervals of the well\n\n        Args:\n            oh_perm (float): faked permeability for open-hole \n    \"\"\"\n    oh_perm: Union[int, float] = 10000</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.CasingCementModel","title":"<code>CasingCementModel</code>","text":"<p>               Bases: <code>DrillingRawModel</code></p> <p>Information about the casing and cementing intervals of the well</p> <p>Parameters:</p> <ul> <li> <code>toc_rkb</code>               (<code>float</code>)           \u2013            <p>top of cement-bond in RKB  </p> </li> <li> <code>boc_rkb</code>               (<code>float</code>)           \u2013            <p>bottom of cement-bond in RKB </p> </li> <li> <code>shoe</code>               (<code>bool</code>)           \u2013            <p>whether or not it has a shoe</p> </li> <li> <code>cb_perm</code>               (<code>float</code>)           \u2013            <p>permeability for cement-bond</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class CasingCementModel(DrillingRawModel):\n    \"\"\" Information about the casing and cementing intervals of the well\n\n        Args:\n          toc_rkb (float): top of cement-bond in RKB  \n          boc_rkb (float): bottom of cement-bond in RKB \n          shoe (bool): whether or not it has a shoe\n          cb_perm (float): permeability for cement-bond\n    \"\"\"\n    toc_rkb: Union[int, float]\n    boc_rkb: Union[int, float]\n    shoe: bool\n    cb_perm: Union[int, float] = 5</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.BarrierModel","title":"<code>BarrierModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Information about the barrier in the well </p> <p>Parameters:</p> <ul> <li> <code>barrier_name</code>               (<code>str</code>)           \u2013            <p>the barrier name </p> </li> <li> <code>barrier_type</code>               (<code>str</code>)           \u2013            <p>the barrier type </p> </li> <li> <code>top_rkb</code>               (<code>float</code>)           \u2013            <p>the top depth in RKB</p> </li> <li> <code>bottom_rkb</code>               (<code>float</code>)           \u2013            <p>the bottom depth in RKB</p> </li> <li> <code>barrier_perm</code>               (<code>float</code>)           \u2013            <p>permeability for the barrier</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class BarrierModel(BaseModel):\n    \"\"\" Information about the barrier in the well \n\n        Args:\n            barrier_name (str): the barrier name \n            barrier_type (str): the barrier type \n            top_rkb (float): the top depth in RKB\n            bottom_rkb (float): the bottom depth in RKB\n            barrier_perm (float): permeability for the barrier\n    \"\"\"\n    barrier_name: str\n    barrier_type: str\n    top_rkb: Union[int, float]\n    bottom_rkb: Union[int, float]\n    barrier_perm: Union[int, float] = 0.5</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.GeologyModel","title":"<code>GeologyModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The geological units encountered in the well</p> <p>Parameters:</p> <ul> <li> <code>top_rkb</code>               (<code>float</code>)           \u2013            <p>top depth in RKB</p> </li> <li> <code>geol_unit</code>               (<code>str</code>)           \u2013            <p>name </p> </li> <li> <code>reservoir_flag</code>               (<code>bool</code>)           \u2013            <p>whether or not it is considered a reservoir</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class GeologyModel(BaseModel):\n    \"\"\" The geological units encountered in the well\n\n        Args:\n            top_rkb (float): top depth in RKB\n            geol_unit (str): name \n            reservoir_flag (bool): whether or not it is considered a reservoir  \n    \"\"\"\n    top_rkb: Union[int, float]\n    geol_unit: str\n    reservoir_flag: bool</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.AssumptionsModel","title":"<code>AssumptionsModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>model for assumptions</p> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class AssumptionsModel(BaseModel):\n    \"\"\" model for assumptions\n    \"\"\"\n    pass</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.ReservoirPressureModel","title":"<code>ReservoirPressureModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for reservoir pressure</p> <p>Parameters:</p> <ul> <li> <code>depth_msl</code>               (<code>float</code>)           \u2013            <p>mean sea level depth</p> </li> <li> <code>RP1</code>               (<code>str</code>)           \u2013            <p>reservoir pressure</p> </li> <li> <code>RP2</code>               (<code>str</code>)           \u2013            <p>reservoir pressure</p> </li> <li> <code>RP3</code>               (<code>str</code>)           \u2013            <p>reservoir pressure</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class ReservoirPressureModel(BaseModel):\n    \"\"\" Model for reservoir pressure\n\n        Args:\n            depth_msl (float): mean sea level depth\n            RP1 (str): reservoir pressure\n            RP2 (str): reservoir pressure\n            RP3 (str): reservoir pressure\n    \"\"\"\n    depth_msl: Union[int, float]\n    RP1: Union[str, float, int, None] = None\n    RP2: Union[str, float, int, None] = None\n    RP3: Union[str, float, int, None] = None</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.CO2DatumModel","title":"<code>CO2DatumModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for CO2 datum. Note it is not used.</p> <p>Parameters:</p> <ul> <li> <code>co2_msl</code>               (<code>float</code>)           \u2013            <p>CO2 datum depth</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class CO2DatumModel(BaseModel):\n    \"\"\" Model for CO2 datum. Note it is not used.\n\n        Args:\n            co2_msl (float): CO2 datum depth\n    \"\"\"\n    co2_msl: Union[int, float]</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.MainBarrierModel","title":"<code>MainBarrierModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>model for main barrier</p> <p>Parameters:</p> <ul> <li> <code>barrier_name</code>               (<code>str</code>)           \u2013            <p>barrier name for proxy compute</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class MainBarrierModel(BaseModel):\n    \"\"\" model for main barrier\n\n        Args:\n            barrier_name (str): barrier name for proxy compute\n    \"\"\"\n    barrier_name: str</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.BarrierPermeabilityModel","title":"<code>BarrierPermeabilityModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>model for Barrier permeability</p> <p>Parameters:</p> <ul> <li> <code>quality</code>               (<code>str</code>)           \u2013            <p>list of quality level</p> </li> <li> <code>kv</code>               (<code>float</code>)           \u2013            <p>list of permeability values</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class BarrierPermeabilityModel(BaseModel):\n    \"\"\" model for Barrier permeability\n\n        Args:\n            quality (str): list of quality level\n            kv (float): list of permeability values\n    \"\"\"\n    quality: Union[List[str], None] = None\n    kv: List[Union[float, int]]</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model","title":"<code>src.WellClass.libs.models.well_model</code>","text":""},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model.MetaDataModel","title":"<code>MetaDataModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>meta data Args:     namespace (str): name space     name (str): can use it for project name     author (str): who made this yaml file</p> Source code in <code>src/WellClass/libs/models/well_model.py</code> <pre><code>class MetaDataModel(BaseModel):\n    \"\"\" meta data\n        Args:\n            namespace (str): name space\n            name (str): can use it for project name\n            author (str): who made this yaml file\n    \"\"\"\n    namespace: str = 'screen'\n    name: Union[str, None] = None\n    author: Union[str, None] = None</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model.WellSpec","title":"<code>WellSpec</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>specs for standard well information Args:     well_header (WellHeaderModel): well header information     drilling (list[DrillingModel]): list of drilling information     casing_cement (list[CasingCementModel]): list of casing information     barrier (list[BarrierModel]):  list of barrier information     barrier_permeability (BarrierPermeabilityModel): list of barrier permeability     geology (list[GeologyModel]): list of geology, such as formations, information     assumptions (AssumptionsModel): misceleaneous information     co2_datum (CO2DatumModel): co2 datum</p> Source code in <code>src/WellClass/libs/models/well_model.py</code> <pre><code>class WellSpec(BaseModel):\n    \"\"\" specs for standard well information\n        Args:\n            well_header (WellHeaderModel): well header information\n            drilling (list[DrillingModel]): list of drilling information\n            casing_cement (list[CasingCementModel]): list of casing information\n            barrier (list[BarrierModel]):  list of barrier information\n            barrier_permeability (BarrierPermeabilityModel): list of barrier permeability\n            geology (list[GeologyModel]): list of geology, such as formations, information\n            assumptions (AssumptionsModel): misceleaneous information\n            co2_datum (CO2DatumModel): co2 datum \n    \"\"\"\n    well_header: WellHeaderModel\n    drilling: Union[List[DrillingModel], None] = None\n    casing_cement: Union[List[CasingCementModel], None] = None\n    barriers: Union[List[BarrierModel], None] = None\n    barrier_permeability: Union[BarrierPermeabilityModel, None] = None\n    geology: Union[List[GeologyModel], None] = None\n    assumptions: Union[AssumptionsModel, None] = None\n    co2_datum: Union[float, int]                                       # CO2DatumModel</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model.WellPressureSpec","title":"<code>WellPressureSpec</code>","text":"<p>               Bases: <code>WellSpec</code></p> <p>extra specs for pressure information Args:     reservoir_pressure (ReservoirPressureModel): general reservoir pressure information     main_barrier (str): main barrier name to compute pressure</p> Source code in <code>src/WellClass/libs/models/well_model.py</code> <pre><code>class WellPressureSpec(WellSpec):\n    \"\"\" extra specs for pressure information\n        Args:\n            reservoir_pressure (ReservoirPressureModel): general reservoir pressure information\n            main_barrier (str): main barrier name to compute pressure\n    \"\"\"\n    reservoir_pressure: Union[ReservoirPressureModel, None] = None\n    main_barrier: Union[str, None] = None</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model.WellModel","title":"<code>WellModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>model including all parameters Args:     apiVersion (str): current version of this yaml format     kind (str): for GaP     metadata (MetaDataModel): miscelaneous data     spec (WellPressureSpec): well specification</p> Source code in <code>src/WellClass/libs/models/well_model.py</code> <pre><code>class WellModel(BaseModel):\n    \"\"\" model including all parameters\n        Args:\n            apiVersion (str): current version of this yaml format\n            kind (str): for GaP\n            metadata (MetaDataModel): miscelaneous data\n            spec (WellPressureSpec): well specification\n    \"\"\"\n    apiVersion: str = 'well/v0.1'\n    kind: str = 'Well'\n    metadata: Union[MetaDataModel, None] = None\n    spec: WellPressureSpec</code></pre>"},{"location":"code_references/well_class/well_class/","title":"Well class","text":""},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_raw","title":"<code>src.WellClass.libs.well_class.well_raw</code>","text":"<p>How to initialize:</p> <pre><code>import well_class\n\nINDATA          = &lt;path to a csv-file with the well-data&gt;\n\n#Reads the csv-file and organize the data into a dict of dataframes\n\nwell_df         = well_class.csv_parser(INDATA)                          </code></pre> <p>Then the class is initialized with a lot of explicit calls. (Bad structure - should been done in one go: <code>mywell = Well(INDATA)</code>)</p> <pre><code>mywell          = well_class.Well(\n                       header       = well_df['well_header'],\n                       reservoir_P  = well_df['reservoir_pressure'],\n                       drilling     = well_df['drilling'],\n                       casings      = well_df['casing_cement'],\n                       barriers     = well_df['barriers'],\n                       geology      = well_df['geology'],\n                       main_barrier = well_df['main_barrier'],\n                       barrier_perm = well_df['barrier_permeability'],\n                       co2_datum    = well_df['co2_datum']\n                   )</code></pre> <p>Now additional functionalities that can be explicitely called are  <pre><code>   .plot_pt()\n\n   .plot_pressure()  + plt.show()\n\n   .plot_sketch()    + plt.show()</code></pre></p>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_raw.WellRaw","title":"<code>WellRaw</code>  <code>dataclass</code>","text":"<p>Basic user input well information</p> <p>Parameters:</p> <ul> <li> <code>header</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>well header</p> </li> <li> <code>drilling</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>drilling well</p> </li> <li> <code>casings</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>well casing</p> </li> <li> <code>barriers</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>barrier information</p> </li> <li> <code>barrier_perm</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>barrier permeabilities</p> </li> <li> <code>geology</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>gelogical formation</p> </li> <li> <code>co2_datum</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>co2 datum value</p> </li> </ul> Source code in <code>src/WellClass/libs/well_class/well_raw.py</code> <pre><code>@dataclass              # @dataclass(kw_only=True)\nclass WellRaw:\n    \"\"\" Basic user input well information\n\n        Args:\n            header (dict): well header\n            drilling (dict): drilling well\n            casings (dict): well casing\n            barriers (dict): barrier information\n            barrier_perm (dict): barrier permeabilities\n            geology (dict): gelogical formation\n            co2_datum (float): co2 datum value\n    \"\"\"\n    header        : dict = None\n    drilling      : dict = None\n    casings       : dict = None\n    barriers      : dict = None\n    barrier_perm  : dict = None\n    geology       : dict = None\n    co2_datum     : Union[float, int] = None\n    inventory     : dict = None\n\n    def __post_init__(self):\n        \"\"\" compute basic well information\n        \"\"\"\n        self._check_inventory()\n        self._process_drilling()\n        self._process_casings()\n        self._process_barriers()\n        self._process_geology()\n\n    def _check_inventory(self):\n\n        \"\"\"\n        process to keep track of what has been declared as input.\n        \"\"\"\n        self.inventory = dict()\n\n        self.inventory['drilling'] = True\n        self.inventory['casings']  = True\n        self.inventory['barriers'] = True\n        self.inventory['geology'] = True\n\n        if self.drilling == None:\n            print('No drilling table declared.')\n            \"\"\"\n            If no drilling table is declared, ignore the casings table as well\n            \"\"\"\n            self.inventory['drilling'] = False\n            self.inventory['casings'] = False\n\n        if self.casings == None:\n            print('No casings table declared.')\n            self.inventory['casings'] = False\n\n        if self.barriers == None:\n            print('No barriers table declared.')\n            self.inventory['barriers'] = False\n\n        if self.geology == None:\n            print('No geology table declared.')\n            self.inventory['geology'] = False\n\n\n\n\n\n    def _process_drilling(self):\n\n        if not self.inventory['drilling']:\n            \"\"\"\n            If no drilling table is declared, create a dummy well with info from the header\n            \"\"\"\n            _well_rkb = self.header['well_rkb']\n            _well_td_rkb = self.header['well_td_rkb']\n            _sf_depth_msl = self.header['sf_depth_msl']\n\n            self.drilling = [{'top_rkb': _sf_depth_msl + _well_rkb, 'bottom_rkb': _well_td_rkb, 'diameter_in': 17.5, 'oh_perm': 10000}] \n\n        drilling_df = pd.DataFrame(self.drilling)\n\n        drilling_df['diameter_m'] = drilling_df['diameter_in'] * scipy.constants.inch       #0.0254\n        drilling_df['top_msl']    = drilling_df['top_rkb'] - self.header['well_rkb']\n        drilling_df['bottom_msl'] = drilling_df['bottom_rkb'] - self.header['well_rkb']\n\n        # validate drilling\n        valid_drilling(drilling_df)\n\n        self.drilling = drilling_df.to_dict()\n\n    def _process_casings(self):\n\n        if not self.inventory['casings']:\n            \"\"\"\n            If no casings table is declared, create a dummy well with info from the header\n            \"\"\"\n            _well_rkb = self.header['well_rkb']\n            _well_td_rkb = self.header['well_td_rkb']\n            _sf_depth_msl = self.header['sf_depth_msl']\n            _diameter_in = pd.DataFrame(self.drilling)['diameter_in'].min() - 2\n\n            self.casings = [{'top_rkb': _sf_depth_msl + _well_rkb,\n                             'bottom_rkb': _well_td_rkb,\n                             'diameter_in': _diameter_in,\n                             'toc_rkb': _sf_depth_msl + _well_rkb,\n                             'boc_rkb': _well_td_rkb,\n                             'shoe': True,\n                             'cb_perm': 0.05}]\n\n\n        casings_df = pd.DataFrame(self.casings)\n\n        casings_df['diameter_m'] = casings_df['diameter_in'] * scipy.constants.inch         #0.0254\n        casings_df['top_msl']    = casings_df['top_rkb']    - self.header['well_rkb']\n        casings_df['bottom_msl'] = casings_df['bottom_rkb'] - self.header['well_rkb']\n        casings_df['toc_msl']    = casings_df['toc_rkb']    - self.header['well_rkb']\n        casings_df['boc_msl']    = casings_df['boc_rkb']    - self.header['well_rkb']\n\n        # validate casings\n        valid_casings(casings_df)\n\n        self.casings = casings_df.to_dict()\n\n    def _process_barriers(self):\n\n        if self.inventory['barriers']:\n\n            barriers_df = pd.DataFrame(self.barriers)\n\n            barriers_df['top_msl']    = barriers_df['top_rkb']    - self.header['well_rkb']\n            barriers_df['bottom_msl'] = barriers_df['bottom_rkb'] - self.header['well_rkb']\n\n            # barriers_df.set_index('barrier_name', inplace=True)\n            self.barriers = barriers_df.to_dict()\n\n    def _process_geology(self):\n\n        if self.inventory['barriers']:\n\n            geology_df = pd.DataFrame(self.geology)\n\n            geology_df = geology_df.dropna(how='all')\n            geology_df = geology_df.reset_index(drop=True)\n\n            geology_df['top_msl']  = geology_df['top_rkb'] - self.header['well_rkb']\n            geology_df['base_msl'] = geology_df['top_msl'] - geology_df['top_msl'].diff(periods=-1)\n            geology_df.loc[geology_df.index.max(), 'base_msl'] = self.header['well_td_rkb'] - self.header['well_rkb']\n\n            self.geology = geology_df.to_dict()\n\n    @property\n    def to_json(self):\n        return json.dumps(self.__dict__, indent=4)</code></pre>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_raw.WellRaw.__post_init__","title":"<code>__post_init__()</code>","text":"<p>compute basic well information</p> Source code in <code>src/WellClass/libs/well_class/well_raw.py</code> <pre><code>def __post_init__(self):\n    \"\"\" compute basic well information\n    \"\"\"\n    self._check_inventory()\n    self._process_drilling()\n    self._process_casings()\n    self._process_barriers()\n    self._process_geology()</code></pre>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_class","title":"<code>src.WellClass.libs.well_class.well_class</code>","text":"<p>How to initialize:</p> <pre><code>import well_class\n\nINDATA          = &lt;path to a csv-file with the well-data&gt;\n\n#Reads the csv-file and organize the data into a dict of dataframes\n\nwell_df         = well_class.csv_parser(INDATA)                          </code></pre> <p>Then the class is initialized with a lot of explicit calls. (Bad structure - should been done in one go: <code>mywell = Well(INDATA)</code>) <pre><code>mywell          = well_class.Well(\n                       header       = well_df['well_header'],\n                       reservoir_P  = well_df['reservoir_pressure'],\n                       drilling     = well_df['drilling'],\n                       casings      = well_df['casing_cement'],\n                       barriers     = well_df['barriers'],\n                       geology      = well_df['geology'],\n                       main_barrier = well_df['main_barrier'],\n                       barrier_perm = well_df['barrier_permeability'],\n                       co2_datum    = well_df['co2_datum']\n                   )</code></pre></p> <p>Now additional functionalities that can be explicitely called are  <pre><code>   .plot_pt()\n\n   .plot_pressure()  + plt.show()\n\n   .plot_sketch()    + plt.show()</code></pre></p>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_class.Well","title":"<code>Well</code>  <code>dataclass</code>","text":"<p>               Bases: <code>WellRaw</code></p> <p>This contains not only the basic well information but also its computed information.</p> <p>Parameters:</p> <ul> <li> <code>borehole</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>for borehole information</p> </li> <li> <code>cement_bond</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>contains information about cement bond</p> </li> <li> <code>annulus</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>gap between casing and openhole</p> </li> <li> <code>barriers_mod</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>extra information about barriers</p> </li> <li> <code>barriers_names</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>reorgainze barrier names</p> </li> </ul> Source code in <code>src/WellClass/libs/well_class/well_class.py</code> <pre><code>@dataclass              # @dataclass(kw_only=True)\nclass Well(WellRaw):\n    \"\"\" This contains not only the basic well information but also its computed information.\n\n        Args:\n            borehole (dict): for borehole information\n            cement_bond (dict): contains information about cement bond\n            annulus (dict): gap between casing and openhole\n            barriers_mod (dict): extra information about barriers\n            barriers_names (dict): reorgainze barrier names\n    \"\"\"\n    borehole      : dict = None\n    cement_bond   : dict = None\n    annulus       : dict = None\n    barriers_mod  : dict = None\n    barriers_names: dict = None\n\n    def __post_init__(self):\n\n        super().__post_init__()\n\n        self._compute_well()\n\n    def _compute_well(self):\n        \"\"\" compute extra well information\n        \"\"\"\n\n        self.borehole = compute_borehole(self.casings, self.drilling)\n        self.cement_bond = compute_cement_bond(self.casings, self.drilling)\n        self.annulus= compute_annulus(self.casings, self.drilling)\n\n        if self.inventory['barriers']:\n            self.barriers_mod = compute_barriers_diam(self.barriers, self.borehole)\n            self.barriers_names = get_barriers_names(self.barriers_mod)\n\n    def compute_barrier_props(self, barrier_name: str) -&gt; dict:\n        \"\"\" Compute barrier geometrical information\n\n            Args:\n               barrier_name (str): barrier name \n        \"\"\"\n\n        # for convenience\n        barriers_mod = self.barriers_mod\n        barriers_names = self.barriers_names\n\n        # properties\n        barrier_props = {}\n\n        # height/depth\n        barrier_h_d = get_barrier_height_and_depth(barriers_mod, barriers_names, barrier_name)\n        barrier_props.update(barrier_h_d)\n\n        # radius\n        barrier_r = get_barrier_radius(barriers_mod, barriers_names, barrier_name)\n        barrier_props.update(barrier_r)\n\n        return barrier_props\n\n    @property\n    def to_json(self):\n        return json.dumps(self.__dict__, indent=4)</code></pre>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_class.Well.compute_barrier_props","title":"<code>compute_barrier_props(barrier_name: str) -&gt; dict</code>","text":"<p>Compute barrier geometrical information</p> <p>Parameters:</p> <ul> <li> <code>barrier_name</code>               (<code>str</code>)           \u2013            <p>barrier name</p> </li> </ul> Source code in <code>src/WellClass/libs/well_class/well_class.py</code> <pre><code>def compute_barrier_props(self, barrier_name: str) -&gt; dict:\n    \"\"\" Compute barrier geometrical information\n\n        Args:\n           barrier_name (str): barrier name \n    \"\"\"\n\n    # for convenience\n    barriers_mod = self.barriers_mod\n    barriers_names = self.barriers_names\n\n    # properties\n    barrier_props = {}\n\n    # height/depth\n    barrier_h_d = get_barrier_height_and_depth(barriers_mod, barriers_names, barrier_name)\n    barrier_props.update(barrier_h_d)\n\n    # radius\n    barrier_r = get_barrier_radius(barriers_mod, barriers_names, barrier_name)\n    barrier_props.update(barrier_r)\n\n    return barrier_props</code></pre>"},{"location":"code_references/well_class/well_pressure/","title":"Well pressure","text":""},{"location":"code_references/well_class/well_pressure/#src.WellClass.libs.well_pressure.Pressure","title":"<code>src.WellClass.libs.well_pressure.Pressure</code>","text":""},{"location":"code_references/well_class/well_pressure/#src.WellClass.libs.well_pressure.Pressure.Pressure","title":"<code>Pressure</code>  <code>dataclass</code>","text":"<p>Manages pressure scenarios for a legacy well based on geothermal gradient and fluid properties.</p> <p>Attributes:</p> <ul> <li> <code>sf_depth_msl</code>               (<code>float</code>)           \u2013            <p>Seafloor depth relative to mean sea level (MSL) in meters.</p> </li> <li> <code>well_td_rkb</code>               (<code>float</code>)           \u2013            <p>Total depth of the well relative to the rotary kelly bushing (RKB) in meters.</p> </li> <li> <code>well_rkb</code>               (<code>float</code>)           \u2013            <p>Rotary kelly bushing elevation in meters.</p> </li> <li> <code>sf_temp</code>               (<code>float</code>)           \u2013            <p>Seafloor temperature in degrees Celsius.</p> </li> <li> <code>geo_tgrad</code>               (<code>float</code>)           \u2013            <p>Geothermal gradient in degrees Celsius per kilometer.</p> </li> <li> <code>pvt_path</code>               (<code>Union[str, Path]</code>)           \u2013            <p>Path to the PVT data files.</p> </li> <li> <code>fluid_type</code>               (<code>str</code>)           \u2013            <p>Name of the fluid stored in PVT data to use in pressure scenarios.</p> </li> <li> <code>z_fluid_contact</code>               (<code>float</code>)           \u2013            <p>Depth of the fluid contact in meters.</p> </li> <li> <code>p_fluid_contact</code>               (<code>float</code>)           \u2013            <p>Pressure at the fluid contact in bars.</p> </li> <li> <code>z_resrv</code>               (<code>float</code>)           \u2013            <p>Depth of the reservoir in meters.</p> </li> <li> <code>p_resrv</code>               (<code>float</code>)           \u2013            <p>Pressure at the reservoir in bars.</p> </li> <li> <code>fluid_composition</code>               (<code>str</code>)           \u2013            <p>Composition of the fluid.</p> </li> <li> <code>pvt_data</code>               (<code>Dict[str, Dict[str, ndarray]]</code>)           \u2013            <p>PVT data for the fluid and brine.</p> </li> <li> <code>brine_interpolator</code>               (<code>RectBivariateSpline</code>)           \u2013            <p>Interpolator for brine PVT data.</p> </li> <li> <code>fluid_interpolator</code>               (<code>RectBivariateSpline</code>)           \u2013            <p>Interpolator for fluid PVT data.</p> </li> <li> <code>ip_shmin_data</code>               (<code>ndarray</code>)           \u2013            <p>User-provided minimum horizontal stress data.</p> </li> <li> <code>init_curves</code>               (<code>DataFrame</code>)           \u2013            <p>Initial curves for depth, temperature, hydrostatic pressure, and minimum horizontal stress.</p> </li> <li> <code>scenario_manager</code>               (<code>PressureScenarioManager</code>)           \u2013            <p>Manager for pressure scenarios.</p> </li> <li> <code>input_scenarios</code>               (<code>Dict[str, Union[float, str, None]]</code>)           \u2013            <p>Input scenarios for pressure calculations.</p> </li> <li> <code>default_hs_scenario</code>               (<code>bool</code>)           \u2013            <p>Flag indicating whether to compute the default hydrostatic scenario.</p> </li> <li> <code>salinity</code>               (<code>float</code>)           \u2013            <p>Salinity of the fluid in percentage (default is 3.5% for seawater).</p> </li> <li> <code>shmin_gradient</code>               (<code>float</code>)           \u2013            <p>Gradient for Shmin calculation (default is SHMIN_FAC).</p> </li> </ul> Source code in <code>src/WellClass/libs/well_pressure/Pressure.py</code> <pre><code>@dataclass\nclass Pressure:\n    \"\"\"\n    Manages pressure scenarios for a legacy well based on geothermal gradient and fluid properties.\n\n    Attributes:\n        sf_depth_msl (float): Seafloor depth relative to mean sea level (MSL) in meters.\n        well_td_rkb (float): Total depth of the well relative to the rotary kelly bushing (RKB) in meters.\n        well_rkb (float): Rotary kelly bushing elevation in meters.\n        sf_temp (float): Seafloor temperature in degrees Celsius.\n        geo_tgrad (float): Geothermal gradient in degrees Celsius per kilometer.\n        pvt_path (Union[str, Path]): Path to the PVT data files.\n        fluid_type (str): Name of the fluid stored in PVT data to use in pressure scenarios.\n        z_fluid_contact (float, optional): Depth of the fluid contact in meters.\n        p_fluid_contact (float, optional): Pressure at the fluid contact in bars.\n        z_resrv (float, optional): Depth of the reservoir in meters.\n        p_resrv (float, optional): Pressure at the reservoir in bars.\n        fluid_composition (str, optional): Composition of the fluid.\n        pvt_data (Dict[str, Dict[str, np.ndarray]]): PVT data for the fluid and brine.\n        brine_interpolator (RectBivariateSpline): Interpolator for brine PVT data.\n        fluid_interpolator (RectBivariateSpline): Interpolator for fluid PVT data.\n        ip_shmin_data (np.ndarray, optional): User-provided minimum horizontal stress data.\n        init_curves (pd.DataFrame): Initial curves for depth, temperature, hydrostatic pressure, and minimum horizontal stress.\n        scenario_manager (PressureScenarioManager): Manager for pressure scenarios.\n        input_scenarios (Dict[str, Union[float, str, None]]): Input scenarios for pressure calculations.\n        default_hs_scenario (bool): Flag indicating whether to compute the default hydrostatic scenario.\n        salinity (float): Salinity of the fluid in percentage (default is 3.5% for seawater).\n        shmin_gradient (float): Gradient for Shmin calculation (default is SHMIN_FAC).\n    \"\"\"\n\n    sf_depth_msl: float\n    well_td_rkb: float\n    well_rkb: float\n    sf_temp: float\n    geo_tgrad: float  # Geothermal gradient in degC/km\n    pvt_path: Union[str, Path]\n    fluid_type: str\n    z_fluid_contact: Optional[float] = None\n    p_fluid_contact: Optional[float] = None\n    z_resrv: Optional[float] = None\n    p_resrv: Optional[float] = None\n    fluid_composition: Optional[str] = None\n    specific_gravity: Optional[float] = None\n    rho_brine: Optional[float] = None  # Density of brine in kg/m^3, if known\n    pvt_data: Dict[str, Dict[str, np.ndarray]] = field(init=False)\n    brine_interpolator: RectBivariateSpline = field(init=False)\n    fluid_interpolator: RectBivariateSpline = field(init=False)\n    ip_shmin_data: np.ndarray = field(default=None)  # User-provided Shmin data\n    init_curves: pd.DataFrame = field(init=False)\n    scenario_manager: PressureScenarioManager = field(init=False)\n    input_scenarios: Dict[str, Optional[Union[float, str]]] = field(default_factory=dict)\n    default_hs_scenario: bool = True\n    salinity: float = 3.5  # Salinity in percentage (default is 3.5% for seawater)\n    shmin_gradient: float = SHMIN_FAC  # Gradient for Shmin calculation\n\n    def __post_init__(self):\n        \"\"\"\n        Initializes PVT data, interpolators, initial curves, and manages scenarios\n        after class instantiation.\n        \"\"\"\n        self.pvt_data = self._load_pvt_data()\n        self._initialize_interpolators()\n        self.init_curves = self._compute_init_curves()\n        self.scenario_manager = PressureScenarioManager()\n        self.manage_scenarios()\n\n    def _load_pvt_data(self):\n        \"\"\"Load PVT data based on specific gravity and fluid type.\"\"\"\n        if self.specific_gravity is not None:\n            return load_pvt_data(self.pvt_path, load_fluid=False)\n        else:\n            pvt_data = load_pvt_data(self.pvt_path, self.fluid_type, load_fluid=True)\n            self.fluid_composition = pvt_data[self.fluid_type][\"metadata\"][\"composition\"]\n            return pvt_data\n\n    def _setup_init_curves(self, depth_array) -&gt; pd.DataFrame:\n        init_curves = pd.DataFrame(\n            {\n                \"depth\": depth_array,\n                \"temperature\": [np.nan] * len(depth_array),\n                \"hydrostatic_pressure\": [np.nan] * len(depth_array),\n                \"min_horizontal_stress\": [np.nan] * len(depth_array),\n            }\n        )\n        return init_curves\n\n    def _compute_init_curves(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Computes initial curves for depth, temperature, hydrostatic pressure, and minimum horizontal stress.\n\n        Returns:\n            pd.DataFrame: DataFrame containing the initial curves.\n        \"\"\"\n        # Logic to compute depth, temperature, hydrostatic pressure, and Shmin\n        # Return a pandas DataFrame with these initial curves\n        depth_curve = self._calculate_depth_curve()\n        init_curves = self._setup_init_curves(depth_array=depth_curve)\n        init_curves[\"temperature\"] = self._calculate_temperature_curve(depth_curve)\n        init_curves[\"hydrostatic_pressure\"] = self._calculate_hydrostatic_pressure(init_curves)\n        init_curves[\"min_horizontal_stress\"] = self._calculate_shmin(depth_curve, init_curves[\"hydrostatic_pressure\"])\n\n        return init_curves\n\n    def _initialize_interpolators(self, load_fluid: bool = True):\n        # Initialize the brine interpolator\n        pressure_vector = self.pvt_data[\"pressure\"]\n        temperature_vector = self.pvt_data[\"temperature\"]\n\n        water_rho_matrix = self.pvt_data[\"brine\"][\"rho\"]\n\n        t_matrix, p_matrix = np.meshgrid(pressure_vector, temperature_vector)\n\n        # Correct water density for salinity using Lalibert\u00e9 and Cooper model\n        brine_rho_matrix = corr_rhobrine_LaliberteCopper(self.salinity, t_matrix, p_matrix, water_rho_matrix)\n\n        self.brine_interpolator = RectBivariateSpline(pressure_vector, temperature_vector, brine_rho_matrix)\n\n        # Initialize the fluid interpolator based on the fluid type\n        if self.specific_gravity is None:\n            fluid_rho_matrix = self.pvt_data[self.fluid_type][\"rho\"]\n            self.fluid_interpolator = RectBivariateSpline(pressure_vector, temperature_vector, fluid_rho_matrix)\n        else:\n            # If specific gravity is provided, set fluid_interpolator to None\n            self.fluid_interpolator = None\n\n    def _calculate_depth_curve(self) -&gt; np.ndarray:\n        # Make the depth-vector from msl and downwards\n        dz = 1.0\n        td_msl = self.well_td_rkb - self.well_rkb\n        z_bottom = int(td_msl) + 500\n        z_vec = np.arange(0, z_bottom, dz)\n\n        return z_vec\n\n    def _calculate_temperature_curve(self, depth_curve: np.ndarray) -&gt; np.ndarray:\n        # Calculate depth sample points based on well depth and seabed depth\n        temperature_curve = self.sf_temp + np.maximum(0, (self.geo_tgrad * (depth_curve - self.sf_depth_msl)) / 1e3)\n\n        return temperature_curve\n\n    def _calculate_hydrostatic_pressure(\n        self,\n        init_curves: pd.DataFrame,\n    ) -&gt; np.ndarray:\n        # Compute hydrostatic pressure using density data from pvt_data and integrate pressure\n\n        if self.rho_brine is not None:\n            hydrostatic_pressure = (const.atm + init_curves[\"depth\"] * self.rho_brine * const.g) / const.bar\n\n        else:\n            # hydrostatic_pressure = compute_hydrostatic_pressure(depth_array = depth_curve,\n            #                                  temperature_array = temperature_curve,\n            #                                  pvt_data = self.pvt_data)\n\n            hydrostatic_pressure, _ = _integrate_pressure(\n                init_curves=init_curves,\n                reference_depth=0,\n                reference_pressure=const.atm / const.bar,\n                pvt_data=self.pvt_data,\n                fluid_key=\"brine\",\n                interpolator=self.brine_interpolator,\n            )\n\n        return hydrostatic_pressure\n\n    def _calculate_shmin(self, depth_array: np.ndarray, hydrostatic_pressure_curve: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Compute Shmin based on user-provided data or an empirical formula.\n\n        Args:\n            depth_array (np.ndarray): Array of depth values.\n            hydrostatic_pressure_curve (np.ndarray): Array of hydrostatic pressure values.\n\n        Returns:\n            np.ndarray: Array of Shmin values.\n        \"\"\"\n        pressure_ml = np.interp(self.sf_depth_msl, depth_array, hydrostatic_pressure_curve)\n\n        if self.ip_shmin_data is not None:\n            # User has provided custom Shmin data, so interpolate it\n            depth_values, shmin_values = self.ip_shmin_data.T\n\n            if min(depth_values) &gt; self.sf_depth_msl:\n                warnings.warn(\n                    f\"No Shmin data between seafloor depth ({self.sf_depth_msl}) and minimum provided depth ({min(depth_values)}). \"\n                    \"Extrapolating using hydrostatic pressure at seafloor.\"\n                )\n\n            else:\n                filtered_depth_values = depth_values[depth_values &gt;= self.sf_depth_msl]\n                filtered_shmin_values = shmin_values[depth_values &gt;= self.sf_depth_msl]\n\n                depth_values = filtered_depth_values\n                shmin_values = filtered_shmin_values\n\n            # Remove duplicates while keeping the first occurrence\n            unique_indices = np.unique(depth_values, return_index=True)[1]\n            depth_values = depth_values[np.sort(unique_indices)]\n            shmin_values = shmin_values[np.sort(unique_indices)]\n\n            # Insert the seafloor depth and pressure at mudline into the arrays\n            depth_values = np.insert(depth_values, 0, self.sf_depth_msl)\n            shmin_values = np.insert(shmin_values, 0, pressure_ml)\n\n            # Insert values af MSL\n            depth_values = np.insert(depth_values, 0, 0)\n            shmin_values = np.insert(shmin_values, 0, hydrostatic_pressure_curve[0])\n\n            shmin_interpolator = interp1d(depth_values, shmin_values, bounds_error=False, fill_value=\"extrapolate\")\n\n            shmin_curve = shmin_interpolator(depth_array)\n\n            check_shmin_values = (\n                shmin_curve[depth_array &gt; self.sf_depth_msl] &lt; hydrostatic_pressure_curve[depth_array &gt; self.sf_depth_msl]\n            ).sum() / len(shmin_curve[depth_array &gt; self.sf_depth_msl])\n\n            if np.isclose(check_shmin_values, 1.0):\n                warnings.warn(\n                    f\"Shmin values below seafloor depth ({self.sf_depth_msl}) are below hydrostatic pressure.\\nIssues with PREDICT Shmin data. Shmin values will be set to hydrostatic pressure.\"\n                )\n\n            # Ensure Shmin is equual to hydrostatic pressure above seafloor depth\n            shmin_curve[shmin_curve &lt; hydrostatic_pressure_curve] = hydrostatic_pressure_curve[shmin_curve &lt; hydrostatic_pressure_curve]\n\n        else:\n            # No user data provided, use the empirical formula\n\n            # interpolate hydrostatic pressure at mudline depth (seafloor depth)\n            pressure_ml = np.interp(self.sf_depth_msl, depth_array, hydrostatic_pressure_curve)\n\n            depth_ml = depth_array - self.sf_depth_msl  # depth below mean sea level\n\n            shmin_curve = pressure_ml + depth_ml * self.shmin_gradient\n            # shmin_curve[shmin_curve&lt;0] = hydrostatic_pressure_curve[shmin_curve&lt;0]\n\n        # Ensure Shmin is not below hydrostatic pressure at any depth\n        shmin_curve[depth_array &lt; self.sf_depth_msl] = hydrostatic_pressure_curve[depth_array &lt; self.sf_depth_msl]\n\n        return shmin_curve\n\n    def add_scenario(self, scenario_name: str, **kwargs):\n        if \"fluid_type\" in kwargs and kwargs[\"fluid_type\"] != self.fluid_type:\n            # If fluid_type is provided, load the PVT data for the new fluid type\n            pvt_data = load_pvt_data(self.pvt_path, kwargs[\"fluid_type\"], load_fluid=True)\n            kwargs[\"pvt_data\"] = pvt_data\n            kwargs[\"fluid_composition\"] = pvt_data[kwargs[\"fluid_type\"]][\"metadata\"][\"composition\"]\n\n            temperature_vector = pvt_data[\"temperature\"]\n            pressure_vector = pvt_data[\"pressure\"]\n            rho_matrix = pvt_data[kwargs[\"fluid_type\"]][\"rho\"]\n\n            kwargs[\"fluid_interpolator\"] = RectBivariateSpline(pressure_vector, temperature_vector, rho_matrix)\n\n        elif \"specific_gravity\" in kwargs and kwargs[\"specific_gravity\"] is not None:\n            # If specific_gravity is provided, set fluid_type to None and fluid_interpolator to None\n            kwargs[\"fluid_type\"] = None\n            kwargs[\"fluid_interpolator\"] = None\n            # kwargs[\"pvt_data\"] = None\n            kwargs[\"fluid_composition\"] = None\n        # # Check that either fluid_type or specific_gravity is provided, but not both\n        if \"fluid_type\" not in kwargs and \"specific_gravity\" not in kwargs:\n            if self.fluid_type is None and self.specific_gravity is None:\n                raise ValueError(\"Either fluid_type or specific_gravity should be provided, not both.\")\n            else:\n                kwargs[\"fluid_type\"] = self.fluid_type\n                kwargs[\"specific_gravity\"] = self.specific_gravity\n\n        defaults = {\n            \"z_fluid_contact\": self.z_fluid_contact,\n            \"p_fluid_contact\": self.p_fluid_contact,\n            \"init_curves\": self.init_curves,\n            \"brine_interpolator\": self.brine_interpolator,\n            \"fluid_type\": self.fluid_type,\n            \"fluid_composition\": self.fluid_composition,\n            \"pvt_data\": self.pvt_data,\n            \"fluid_interpolator\": self.fluid_interpolator,\n            \"specific_gravity\": self.specific_gravity,\n            \"z_resrv\": self.z_resrv,\n            \"p_resrv\": self.p_resrv,\n            \"rho_brine\": self.rho_brine,\n            # Add other default values as needed\n        }\n\n        # Update defaults with user-provided values\n        defaults.update(kwargs)\n\n        # Store the scenario\n        scenario = self.scenario_manager.create_scenario(name=scenario_name, **defaults)\n        scenario.compute_pressure_profile()\n\n    def manage_scenarios(self):\n        # Check if the first scenario is 'None' and should be computed as hydrostatic\n        # Skip the first entry in the input_scenarios dictionary\n\n        if self.input_scenarios:\n            scenarios_iter = iter(self.input_scenarios.items())\n            next(scenarios_iter)\n            for scenario_name, scenario_pressure in scenarios_iter:\n                print(f\"{scenario_pressure=}\")\n                try:\n                    p_delta = float(scenario_pressure)\n                except:\n                    p_delta = None  # Handle cases where pressure is not a float\n                print(f\"{scenario_name=} {scenario_pressure=}\")\n                self.add_scenario(\n                    scenario_name=scenario_name,\n                    p_delta=p_delta,\n                    from_resrvr=True,\n                )\n\n        elif self.z_fluid_contact is not None and self.default_hs_scenario:\n            # Handle default hydrostatic scenario if no input scenarios are provided\n            self.add_scenario(\n                scenario_name=\"hydrostatic\",\n                from_resrvr=True,\n            )\n\n    def compute_barrier_leakage(self, well: Well, barrier_name: str) -&gt; pd.DataFrame:\n        \"\"\"\n        Compute leakage rate from the given barrier\n\n        Args:\n            well (Well): well information\n            barrier_name (str): barrier to check the leakage rate\n        Returns:\n            pd.DataFrame: DataFrame containing leakage rates for different scenarios and permeabilities.\n\n        \"\"\"\n        if well.inventory[\"barriers\"]:\n            # for convenience\n            barrier_perm = well.barrier_perm\n\n            # Estimate CO2 leakage in [tons/day] after a trancient period\n            sc_names = self.scenario_manager.scenarios.keys()\n\n            # Initialize a DataFrame to store the leakage rates\n            df = pd.DataFrame(\n                columns=[\"p_brine_above_barrier\", \"p_fluid_below_barrier\", \"rho_brine_below_barrier\", \"rho_fluid_below_barrier\"], index=sc_names\n            )\n\n            # Retrieve common init curves\n            depth = self.init_curves[\"depth\"].values\n            temperature = self.init_curves[\"temperature\"].values\n\n            # barrier geometries\n            barrier_props = well.compute_barrier_props(barrier_name)\n\n            b_top = barrier_props[\"top\"]\n            b_bottom = barrier_props[\"bottom\"]\n\n            # Retrieve temperature at the top and bottom of the barrier\n            b_top_temp = np.interp(b_top, depth, temperature)\n            b_bottom_temp = np.interp(b_bottom, depth, temperature)\n\n            for sc_name in sc_names:\n                # Retrieve and interpolate pressure and density values\n                p_brine_ab, p_fluid_bb, rho_brine_ab, rho_fluid_bb = self._retrieve_and_interpolate_values(\n                    sc_name=sc_name, top=b_top, bottom=b_bottom, top_temperature=b_top_temp, bottom_temperature=b_bottom_temp\n                )\n\n                # Store retrieved values in the DataFrame\n                df.loc[sc_name, \"p_brine_above_barrier\"] = p_brine_ab\n                df.loc[sc_name, \"p_fluid_below_barrier\"] = p_fluid_bb\n                df.loc[sc_name, \"rho_brine_below_barrier\"] = rho_brine_ab\n                df.loc[sc_name, \"rho_fluid_below_barrier\"] = rho_fluid_bb\n\n                # Check if the barrier has permeabilities\n                try:\n                    perms = barrier_perm[\"kv\"].values()\n                except Exception:\n                    perms = barrier_perm[\"kv\"]\n\n                # Compute leakage rates for different permeabilities and store in df\n                for k in perms:\n                    df[k] = np.nan\n\n                    for idx, row in df.iterrows():\n                        df.loc[idx, k] = leakage_proxy(\n                            rho_fluid_below_barrier=row[\"rho_fluid_below_barrier\"],\n                            rho_brine_below_barrier=row[\"rho_brine_below_barrier\"],\n                            p_fluid_below_barrier=row[\"p_fluid_below_barrier\"],\n                            p_brine_above_barrier=row[\"p_brine_above_barrier\"],\n                            permeability=k,\n                            barrier_props=barrier_props,\n                        )\n\n            return df\n\n        else:\n            print(f\"No barriers declared in well {well.header['well_name']}\")\n\n    def _retrieve_and_interpolate_values(\n        self,\n        sc_name: str,\n        top: float,\n        bottom: float,\n        top_temperature: float,\n        bottom_temperature: float,\n    ) -&gt; tuple:\n        \"\"\"\n        Retrieve and interpolate pressure and density values at the top and bottom of the barrier.\n\n        Args:\n            sc_name (str): Scenario name\n            top (float): Top depth of the barrier\n            bottom (float): Bottom depth of the barrier\n            top_temperature (float): Temperature at the top of the barrier\n            bottom_temperature (float): Temperature at the bottom of the barrier\n            depth (np.ndarray): Depth array\n\n        Returns:\n            tuple: Interpolated pressure and density values (p_brine_above_barrier, p_fluid_below_barrier, rho_brine_above_barrier, rho_fluid_below_barrier)\n        \"\"\"\n        fluid_pressure = self.scenario_manager.scenarios[sc_name].init_curves[\"fluid_pressure\"].to_numpy()\n        hydrst_pressure = self.scenario_manager.scenarios[sc_name].init_curves[\"hydrostatic_pressure\"].to_numpy()\n        depth = self.scenario_manager.scenarios[sc_name].init_curves[\"depth\"].to_numpy()\n        fluid_interp = self.scenario_manager.scenarios[sc_name].fluid_interpolator\n        brine_interp = self.scenario_manager.scenarios[sc_name].brine_interpolator\n\n\n        p_fluid_below_barrier = np.interp(bottom, depth, fluid_pressure)\n        p_brine_above_barrier = np.interp(top, depth, hydrst_pressure)\n\n        rho_fluid_below_barrier = get_rho_from_pvt_data(pressure=p_fluid_below_barrier, temperature=bottom_temperature, rho_interpolator=fluid_interp)\n        rho_brine_above_barrier = get_rho_from_pvt_data(pressure=p_brine_above_barrier, temperature=top_temperature, rho_interpolator=brine_interp)\n\n        return p_brine_above_barrier, p_fluid_below_barrier, rho_brine_above_barrier, rho_fluid_below_barrier\n\n    def scenarios_summary(self):\n        return self.scenario_manager.get_scenarios_summary()</code></pre>"},{"location":"code_references/well_class/well_pressure/#src.WellClass.libs.well_pressure.Pressure.Pressure.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initializes PVT data, interpolators, initial curves, and manages scenarios after class instantiation.</p> Source code in <code>src/WellClass/libs/well_pressure/Pressure.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    Initializes PVT data, interpolators, initial curves, and manages scenarios\n    after class instantiation.\n    \"\"\"\n    self.pvt_data = self._load_pvt_data()\n    self._initialize_interpolators()\n    self.init_curves = self._compute_init_curves()\n    self.scenario_manager = PressureScenarioManager()\n    self.manage_scenarios()</code></pre>"},{"location":"code_references/well_class/well_pressure/#src.WellClass.libs.well_pressure.Pressure.Pressure.compute_barrier_leakage","title":"<code>compute_barrier_leakage(well: Well, barrier_name: str) -&gt; pd.DataFrame</code>","text":"<p>Compute leakage rate from the given barrier</p> <p>Parameters:</p> <ul> <li> <code>well</code>               (<code>Well</code>)           \u2013            <p>well information</p> </li> <li> <code>barrier_name</code>               (<code>str</code>)           \u2013            <p>barrier to check the leakage rate</p> </li> </ul> <p>Returns:     pd.DataFrame: DataFrame containing leakage rates for different scenarios and permeabilities.</p> Source code in <code>src/WellClass/libs/well_pressure/Pressure.py</code> <pre><code>def compute_barrier_leakage(self, well: Well, barrier_name: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute leakage rate from the given barrier\n\n    Args:\n        well (Well): well information\n        barrier_name (str): barrier to check the leakage rate\n    Returns:\n        pd.DataFrame: DataFrame containing leakage rates for different scenarios and permeabilities.\n\n    \"\"\"\n    if well.inventory[\"barriers\"]:\n        # for convenience\n        barrier_perm = well.barrier_perm\n\n        # Estimate CO2 leakage in [tons/day] after a trancient period\n        sc_names = self.scenario_manager.scenarios.keys()\n\n        # Initialize a DataFrame to store the leakage rates\n        df = pd.DataFrame(\n            columns=[\"p_brine_above_barrier\", \"p_fluid_below_barrier\", \"rho_brine_below_barrier\", \"rho_fluid_below_barrier\"], index=sc_names\n        )\n\n        # Retrieve common init curves\n        depth = self.init_curves[\"depth\"].values\n        temperature = self.init_curves[\"temperature\"].values\n\n        # barrier geometries\n        barrier_props = well.compute_barrier_props(barrier_name)\n\n        b_top = barrier_props[\"top\"]\n        b_bottom = barrier_props[\"bottom\"]\n\n        # Retrieve temperature at the top and bottom of the barrier\n        b_top_temp = np.interp(b_top, depth, temperature)\n        b_bottom_temp = np.interp(b_bottom, depth, temperature)\n\n        for sc_name in sc_names:\n            # Retrieve and interpolate pressure and density values\n            p_brine_ab, p_fluid_bb, rho_brine_ab, rho_fluid_bb = self._retrieve_and_interpolate_values(\n                sc_name=sc_name, top=b_top, bottom=b_bottom, top_temperature=b_top_temp, bottom_temperature=b_bottom_temp\n            )\n\n            # Store retrieved values in the DataFrame\n            df.loc[sc_name, \"p_brine_above_barrier\"] = p_brine_ab\n            df.loc[sc_name, \"p_fluid_below_barrier\"] = p_fluid_bb\n            df.loc[sc_name, \"rho_brine_below_barrier\"] = rho_brine_ab\n            df.loc[sc_name, \"rho_fluid_below_barrier\"] = rho_fluid_bb\n\n            # Check if the barrier has permeabilities\n            try:\n                perms = barrier_perm[\"kv\"].values()\n            except Exception:\n                perms = barrier_perm[\"kv\"]\n\n            # Compute leakage rates for different permeabilities and store in df\n            for k in perms:\n                df[k] = np.nan\n\n                for idx, row in df.iterrows():\n                    df.loc[idx, k] = leakage_proxy(\n                        rho_fluid_below_barrier=row[\"rho_fluid_below_barrier\"],\n                        rho_brine_below_barrier=row[\"rho_brine_below_barrier\"],\n                        p_fluid_below_barrier=row[\"p_fluid_below_barrier\"],\n                        p_brine_above_barrier=row[\"p_brine_above_barrier\"],\n                        permeability=k,\n                        barrier_props=barrier_props,\n                    )\n\n        return df\n\n    else:\n        print(f\"No barriers declared in well {well.header['well_name']}\")</code></pre>"}]}