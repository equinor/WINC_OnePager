{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SCREEN","text":"<p>SCREEN stands for \"Simulation-based Comparative Risk Estimation of well leakage in Early phase evaluatioN\".</p>"},{"location":"#introduction","title":"Introduction","text":"<p>The SCREEN project shall provide a workflow and a toolbox to assess CO2 leakage through abandoned wells. </p> <p>In addition to adjacent activities run internally and externally, the project aims to deliver a series of scrip-based tools to assist risk assesment of legacy wells and modelling leakage.</p> <p>The toolbox can be grouped in two main modules: A pre-processing and preliminary assesment, and a detailed simulation workflow as shown in the figure below.</p> <p></p>"},{"location":"#pre-processing-and-preliminary-assesment","title":"Pre-processing and preliminary assesment","text":""},{"location":"#data-preparation","title":"Data Preparation","text":"<p>The first step in using the SCREEN toolbox is to gather all the necessary data. Sources of data include both subsurface data nearby well and specifics about the well construction. Some of this data can ba gathered from internal databases, but some other has to be retrieved manually. Whichever the method, the current solution requires the data to be collected on an input sheet (CSV or YAML file) with tables containing different datasets.</p> <p>To collect the data these are some steps that can be followed:</p> <p>\u2022   Identify the required data: Review the list of required tables and columns in the input data file to determine what information you need to gather. This includes well header information, drilling intervals, casing and cementing intervals, barriers, geological units, and assumptions (see table below).</p> <p>\u2022   Collect the data: Involve both subsurface and well integrity experts involved on the project to provide curated datasets to be used in the evaluation. By doing this, we ensure data has been previously verified. Subsurface data can vary from simple well tops, temperature profiles to more specifics about the quality of the reservoirs involved, potential flow units in the overburden, and the current state of reservoir pressure in case it deviates from hydrostatic. A previous qualitative leakage risk assessment of the wells shall provide the necessary input relevant for the well.</p> <p>\u2022   Organize the data: Organize the data into tables according to the structure of the input data file. Use a spreadsheet program or a text editor to create a CSV file with multiple tables, each separated by a blank line. Ensure that all required tables and columns are included in the input data file and that the data is entered correctly.</p> <p>\u2022   Include assumptions: The assumptions depend on the stage of knowledge of the area. If there is a reservoir model in place, such model should be used to fill in the information for these tables. Otherwise, these should be discussed with the subsurface personnel involved in the project.</p> <p>The input sheet could be defined as aither a YAML or a CSV file. It shall include the following tables:</p> Category Item Property Source Sketch Simulation Well Well header well name well reports   / database :heavy_check_mark: :heavy_check_mark: Well Well header well RKB well reports   / database :heavy_check_mark: :heavy_check_mark: Well Well header well td well reports   / database :heavy_check_mark: :heavy_check_mark: Well Well header water depth /   mudline depth well reports   / database :heavy_check_mark: :heavy_check_mark: Well Bitsize records Top and   bottom depth (MD RKB), diameter well reports :heavy_check_mark: :heavy_check_mark: Well Bitsize records Permeability* assumed :x: :heavy_check_mark: Well Casings Top and   bottom depth (MD RKB), diameter well reports :heavy_check_mark: :heavy_check_mark: Well Casings Permeability* assumed :x: :heavy_check_mark: Well Cement bond Min, max and   most likely top and bottom depth well   assesment :heavy_check_mark: :heavy_check_mark: Well Cement bond Permeability* assumed /   well assesment :x: :heavy_check_mark: Well Barriers/cement plugs Min, max and   most likely top and bottom depth well   assesment :heavy_check_mark: :heavy_check_mark: Well Barriers/cement plugs Permeability* assumed /   well assesment :x: :heavy_check_mark: Subsurface Geological tops Top depth (MD   RKB) well reports   / database :heavy_check_mark: :heavy_check_mark: Subsurface Geological tops Transport   properties (porosity, permeability)** assumed    / asset :heavy_check_mark: :heavy_check_mark: Subsurface Geothermal info Seafloor   temperature assumed    / asset :heavy_check_mark: :heavy_check_mark: Subsurface Geothermal info Temperature   survey (if available) assumed    / asset :heavy_check_mark: :heavy_check_mark: Subsurface Geothermal info Geothermal   gradient assumed    / asset :heavy_check_mark: :heavy_check_mark: Subsurface Initialization Reservoir   pressure (scenarios) asset :heavy_check_mark: :heavy_check_mark: Subsurface Initialization Base of CO2   (CO2-water contact depth) asset :heavy_check_mark: :heavy_check_mark: <p>permeability can be declared as good, average, poor *flow units declaration</p>"},{"location":"#data-visualization-and-proxy-based-leakage-estimation","title":"Data Visualization and Proxy-based Leakage Estimation","text":"<p>Once all the information is tabulated, it can be processed with a python script. The processing will store the data in memory and use it to produce a hybrid geological well-sketch and a pressure-depth plot displaying the fluid pressures of each phase and the minimum horizontal stress.</p> <p>The well sketch combines both subsurface data and well engineering information. It serves as a starting point to identify the main leakage pathways and illustrate the main risks associated with the well.</p> <p>The pressure plot, besides visualizing the provided pressure scenarios, has the necessary input to run a preliminary leakage estimation based on a Darcy-based proxy. This proxy gives an estimate of leakage rates through the main barrier (deepest cement plug). The magnitude will be a function of both the transport properties assigned to the barrier and the resulting phase pressures of each scenario.</p> <p></p>"},{"location":"#detailed-simulation-workflow","title":"Detailed simulation workflow","text":"<p>For wells with larger uncertainties and more complex leakage pathways, a simulation-based approach can assist in generating a more accurate estimate of leakage.</p> <p>By fulfilling the first two modules, the data is ready to be processed through a second script that generates and initializes a simple reservoir model with a finite-volume representation of the legacy well.</p>"},{"location":"#building-the-mesh","title":"Building the mesh","text":"<p>The generated mesh is a coarse mesh with <code>local grid refinement (LGR)</code> in the middle. The higher resolution of the LGR is used to represent well construction details.</p> <p>Due to the cartesian nature of the mesh, the cylindrical shape of the well is turned into a prism. A horizontal cross-section of the well in the LGR is square, with sides meant to preserve the area of the original circle. However, discrepancies between volumes may occur due to mesh resolution.</p> <p>The transport properties of geological units are inherited from coarse grid and updated to represent well. Open borehole is represented by high permeability grid cells. Cement plugs and cement-bond are represented by low permeability cells. Casing is represented by reduction of transmissibility of cell interfaces.</p>"},{"location":"#running-the-simulation","title":"Running the simulation","text":""},{"location":"#exploring-the-simulation-output","title":"Exploring the simulation output","text":""},{"location":"INSTALLATION/","title":"WINC_OnePager","text":"<p>This repository contains source codes and documentation for WINC_OnePager project.</p> <p> </p>"},{"location":"INSTALLATION/#installation-instructions","title":"Installation Instructions","text":"<p>There are two methods to install and run the project - with cloning and without cloning. You can choose depending on whether you need to work with the repository directly or just want to use the package.</p>"},{"location":"INSTALLATION/#with-poetry-recommended-for-dependency-management-in-equinor","title":"With Poetry (Recommended for Dependency Management in Equinor)","text":"<p>Poetry is Equinor's recommended tool complying with IT policy for Python dependency management.</p>"},{"location":"INSTALLATION/#1-prerequisites","title":"1. Prerequisites","text":"<p>Ensure you have Python <code>^3.9</code> installed and accessible in your path.</p>"},{"location":"INSTALLATION/#2-installing-poetry","title":"2. Installing Poetry","text":"<p>If you don't have Poetry installed, you can do so with the following command:</p> <pre><code>curl -sSL https://install.python-poetry.org | python3 </code></pre> <p>After installation, verify that Poetry is correctly installed: <pre><code>poetry --version</code></pre></p>"},{"location":"INSTALLATION/#3a-install-the-project-using-poetry-without-cloning","title":"3A. Install the Project Using Poetry Without Cloning","text":"<p>To install the project without cloning the repository:</p> <p><pre><code>mkdir my-project\n\ncd my-project\n\n# Create a pyproject.toml file with the content described in the original README, then execute:\npoetry init</code></pre> Open the pyproject.toml file. Open the file in your preferred text editor, copy and Paste the follwing contents:</p> <pre><code>[tool.poetry]\nname = \"my-project\"\nversion = \"0.1.0\"\npackage-mode = false  # Add this line\n\n\n[tool.poetry.dependencies]\npython = \"&gt;=3.9,&lt;=3.12\"\n\n[tool.poetry.dependencies.winc-onepager]\ngit = \"git@github.com:equinor/WINC_OnePager.git\"\nrev = \"main\"\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"</code></pre> <p>Save the changes and close the editor. Install dependencies.</p> <pre><code>poetry install</code></pre>"},{"location":"INSTALLATION/#3b-install-the-project-using-poetry-with-cloning","title":"3B. Install the Project Using Poetry With Cloning","text":"<p>To install the project after cloning the repository:</p> <pre><code>git clone https://github.com/equinor/WINC_OnePager\ncd WINC_OnePager\n# Optionally, create a new branch\n# Then execute:\npoetry install</code></pre>"},{"location":"INSTALLATION/#4-activate-the-poetry-environment","title":"4. Activate the Poetry environment:","text":"<pre><code>poetry shell</code></pre>"},{"location":"INSTALLATION/#installation-using-pip-and-a-virtual-environment","title":"Installation Using pip and a Virtual Environment","text":"<p>The installation of the WINC_OnePager project can be done using <code>pip</code>, which is a straightforward approach regardless of cloning. First, ensure that you are in a Python virtual environment to isolate the project dependencies.</p>"},{"location":"INSTALLATION/#1-creating-a-virtual-environment","title":"1. Creating a Virtual Environment","text":"<p>If you haven't already set up a virtual environment, you can create one using Python's built-in <code>venv</code>:</p> <pre><code>python -m venv venv_screen\nsource venv_screen/bin/activate</code></pre> <p>For Windows users, activate the virtual environment with:</p> <pre><code>.\\venv_screen\\Scripts\\activate.bat</code></pre>"},{"location":"INSTALLATION/#2-installing-the-project","title":"2. Installing the Project","text":"<ul> <li> <p>Using <code>pip install .</code>: This method works both when the repository has been cloned and when you have a project directory set up with a pyproject.toml or setup.py file. It installs the current directory as a package along with its dependencies:</p> <pre><code>pip install .</code></pre> <p>This command tells pip to install the current directory (i.e., the project) as a package.</p> </li> <li> <p>Using <code>pip install -r requirements.txt</code>: This method is specific to situations where the repository has been cloned. It will install the dependencies specified in the requirements.txt file:     <pre><code>pip install -r requirements.txt</code></pre></p> </li> </ul>"},{"location":"INSTALLATION/#experiments","title":"Experiments","text":"<p>There are at least two ways to make experimenal runs of the codes. One is to run the experiments with Jupyter lab (notbeooks folder), and the other is commandline option. While Jupyter notebooks are mainly for QC tests and research purposes, the commandline option is aiming for production run.</p>"},{"location":"INSTALLATION/#1-jupyter-notebooks","title":"1. Jupyter notebooks","text":"<p>Jupyter notebooks are located in directory <code>notebooks</code>. To test its functionaries, change current directory to <code>notebooks</code> and launch jupyter notebooks at the commandline: <pre><code>jupyter-lab</code></pre> Or if you prefer, you can run these Jupyter notebooks from Microsoft's VS code.</p> <p>There exist several Jupyter notebooks in the directory:</p> <ul> <li>Notebook Pressure-WellClass.ipynb is used to test pressure. </li> <li>Notebook WellClass_csv_yaml.ipynb is used to test pressure and loading <code>.csv</code> and <code>.yaml</code> input files.</li> </ul>"},{"location":"INSTALLATION/#2-commandline-option","title":"2. Commandline option","text":"<p>Two python scripts for commandline option are available in directory <code>experiments</code>. One script, well_sketch.py, can be used for generating a well sketch, well_sketch_pressure.py can be used for generating both a well sketch and a pressure plot. </p> <p>The followings are some of  the sample runs. In either way, you should run the python script inside the <code>WINC_OnePager</code> directory. </p> <ol> <li>To test well_sketch.py, run either of the followings: <pre><code># 1. for smeaheia_v1\n\npython -m experiments.well_sketch_pressure --config-file ./test_data/examples/smeaheia_v1/smeaheia.yaml -pvt ./test_data/pvt_constants \n\n# 3. for wildcat\n\npython -m experiments.well_sketch_pressure --config-file ./test_data/examples/wildcat/wildcat.yaml -pvt ./test_data/pvt_constants </code></pre></li> </ol>"},{"location":"INSTALLATION/#3-test-data","title":"3. Test data","text":"<p>In order for a quick test of the codes, we include some test dataset in the folder <code>test_data/examples</code>. </p> <p><pre><code>\u251c\u2500\u2500 frigg\n\u2502   \u251c\u2500\u2500 GaP_input_Frigg_v3.csv\n\u2502   \u2514\u2500\u2500 X_5687dev.txt\n\u251c\u2500\u2500 simple_well\n\u2502   \u251c\u2500\u2500 Simple_well.csv\n\u2502   \u2514\u2500\u2500 Simple_well.yaml\n\u251c\u2500\u2500 smeaheia_v1\n\u2502   \u251c\u2500\u2500 GaP_input_Smeaheia_v3.csv\n\u2502   \u2514\u2500\u2500 smeaheia.yaml\n\u251c\u2500\u2500 wildcat\n    \u251c\u2500\u2500 GaP_input_Wildcat_v3.csv\n    \u2514\u2500\u2500 wildcat.yaml\n\n\n## Unit testing and code coverage\nWe are using `pytest` for unit testing and code coverage. The unit testing utilizes `wildcat` as the testing example. So please make sure the saved .pkl files in ```test_data/examples/wildcat/pytest``` exists and is updated. Here is a commandline example:\n```python\npython -m pytest tests</code></pre> This will report the unit testing results. And the following will report not only unit testing but also code coverage: <pre><code>python -m pytest --cov tests</code></pre> or a litle bit more complex command: <pre><code>python -m pytest --cov --cov-branch --cov-report term-missing tests</code></pre></p>"},{"location":"INSTALLATION/#documentation","title":"Documentation","text":"<p>The document can be automatically generated and deployed to github pages. To do that, type the following at the command line: <pre><code>mkdocs gh-deploy</code></pre> It may take some minutes until the documentation goes live. And the generated documentation page can be found at WINC_OnePager docs.</p>"},{"location":"INSTALLATION/#the-code-structures","title":"The code structures","text":"<p>The following represents the current code structures:</p> <pre><code>.\n\u251c\u2500\u2500 CITATION.cff\n\u251c\u2500\u2500 experiments\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 well_pressure_tables.py\n\u2502   \u251c\u2500\u2500 well_sketch_pressure.py\n\u2502   \u2514\u2500\u2500 well_sketch.py\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 notebooks\n\u2502   \u251c\u2500\u2500 Pressure-WellClass.ipynb\n\u2502   \u251c\u2500\u2500 PVT_data.ipynb\n\u2502   \u251c\u2500\u2500 WellClass_csv_yaml.ipynb\n\u2502   \u2514\u2500\u2500 WellClass-onepager.ipynb\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 requirements.txt.frozen\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 WellClass\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 libs\n\u2502       \u251c\u2500\u2500 notebooks\n\u2502       \u251c\u2500\u2500 README.md\n\u2502       \u2514\u2500\u2500 tools\n\u251c\u2500\u2500 test_data\n\u2502   \u2514\u2500\u2500 examples\n\u2502       \u251c\u2500\u2500 frigg\n\u2502       \u251c\u2500\u2500 simple_well\n\u2502       \u251c\u2500\u2500 smeaheia_v1\n\u2502       \u251c\u2500\u2500 wildcat\n\u2502       \u251c\u2500\u2500 wildcat-pflotran\n\u2502       \u2514\u2500\u2500 wildcat-pflotran-2\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 conftest.py\n    \u2514\u2500\u2500 well_class\n        \u2514\u2500\u2500 test_well_class.py</code></pre> <p>It was generated with the linux command <code>tree</code>: <pre><code>tree -I 'docs|site|venv_screen|*pycache*|Equinor*|originals' -L 3</code></pre></p>"},{"location":"mkdocs/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"mkdocs/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs gh-deploy</code> - Deploy the documentation to GitHub page (<code>gh-pages</code> branch)</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"mkdocs/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.</code></pre>"},{"location":"well_class/","title":"WELL CLASS for pre-processing well data","text":""},{"location":"well_class/#data-preparation","title":"Data Preparation","text":"<p>The first step in using the SCREEN method is to gather all the necessary data to build a plugged and abandoned well sketch, along with any relevant subsurface data surrounding the well. This data should be prepared in a CSV file with multiple tables, each separated by a blank line.</p> <p>To collect the data these are some steps that can be followed:</p> <ul> <li> <p>Identify the required data: Review the list of required tables and columns in the input data file to determine what information you need to gather. This includes well header information, drilling intervals, casing and cementing intervals, barriers, geological units, and assumptions.</p> </li> <li> <p>Collect the data: Gather the necessary data from various sources. The information in the first tables should be available from the final well reports. Retrieving the data may involve manually scouting numbers in the reports that could be presented in different places and different formats. Other databases can be referred to retrieve temperature data or updated geological well tops.</p> </li> <li> <p>Verify the data: Check the accuracy and completeness of the data by cross-referencing it with multiple sources and verifying it with domain experts. Ensure that all required tables and columns are included in the input data file and that the data is entered correctly.</p> </li> <li> <p>Organize the data: Organize the data into tables according to the structure of the input data file. Use a spreadsheet program or a text editor to create a CSV file with multiple tables, each separated by a blank line.</p> </li> <li> <p>Include assumptions: The assumptions depend on the stage of knowledge of the area. If there is a reservoir model in place, this should be used to fill in the information for these tables. Otherwise these should discussed with the subsurface personnel involved in the project.</p> </li> </ul> <p>The CSV file shall include the following tables:</p> <ul> <li> <p><code>well_header</code>: This table contains general information about the well, such as its name (well_name), RKB elevation (well_rkb), depth of the sea floor (sf_depth_msl), total depth (well_td_rkb), sea floor temperature (sf_temp), and geothermal gradient (geo_tgrad).</p> </li> <li> <p><code>drilling</code>: This table contains information about the drilling intervals of the well, including the top and bottom depths in RKB (top_rkb, bottom_rkb) and the diameter of the borehole in inches (diameter_in).</p> </li> <li> <p><code>casing_cement</code>: This table contains information about the casing and cementing intervals of the well, including the top and bottom depths in RKB (top_rkb, bottom_rkb), diameter of the casing in inches (diameter_in), top  and bottom of cement-bond in RKB (toc_rkb, boc_rkb), and whether or not it has a shoe (shoe).</p> </li> <li> <p><code>barriers</code>: This table lists the barriers in the well along with their name (barrier_name), type (barrier_type), and top and bottom depths in RKB (top_rkb, bottom_rkb).</p> </li> <li> <p><code>geology</code>: This table lists the geological units encountered in the well along with their top depth in RKB (top_rkb), name (geol_unit), and whether or not they are considered a reservoir (reservoir_flag).</p> </li> <li> <p><code>assumptions</code>: This section includes several tables with information about assumptions used in the analysis, such as reservoir pressure scenarios (reservoir_pressure), CO2 datum depth (co2_datum), main barrier name (main_barrier), and barrier permeability values for different quality levels (barrier_permeability).</p> </li> </ul> <p>Here is an example of how the CSV file could be structured, along with explanations for each table:</p> <pre><code>input_data\n\nwell_header\nwell_name,wellA\nwell_rkb,30\nsf_depth_msl,105\nwell_td_rkb,3997\nsf_temp,4\ngeo_tgrad,40\n\ndrilling\ntop_rkb,bottom_rkb,diameter_in\n132,190,36\n190,444,26\n444,1812,17 1/2\n1812,3942,12 1/4\n3942,3997,8 1/2\n\ncasing_cement\ntop_rkb,bottom_rkb,diameter_in,toc_rkb,boc_rkb,shoe\n132,158,30,132,158,TRUE\n132,439,20,132,439,TRUE\n182,1803,13 3/8,450,1803,TRUE\n\nbarriers\nbarrier_name,barrier_type,top_rkb,bottom_rkb\ncement plug #3,cplug,132,150\ncement plug #2,cplug,1690,1850\ncement plug #1,cplug,2050,2300\n\ngeology\ntop_rkb,geol_unit,reservoir_flag\n132,OVERBURDEN,FALSE\n2122,CAP ROCK,FALSE\n2265,RESERVOIR,TRUE\n\nassumptions\n\nreservoir_pressure\ndepth_msl,RP1,RP2\n2238,90 110\n\nco2_datum\nco2_msl,2370\n\nmain_barrier\nbarrier_name,cplug2\n\nbarrier_permeability\nquality,kv\ngood,0.01\nmid,10\npoor,1.00E+03</code></pre>"},{"location":"well_class/#data-visualization-and-proxy-based-leakage-estimation","title":"Data Visualization and Proxy-based Leakage Estimation","text":"<p>Once all the information is tabulated, it can be processed through the well class. </p> <pre><code>#Import CSV tables\nfilename = r'csv_file.csv'\n\nwell_csv = csv_parser(filename)\n\n#Process well by running well class\nmy_well = Well( header       = well_csv['well_header'], \n                drilling     = well_csv['drilling'],\n                casings      = well_csv['casing_cement'],\n                barriers     = well_csv['barriers'], \n                reservoir_P  = well_csv['reservoir_pressure'],\n                main_barrier = well_csv['main_barrier'],\n                barrier_perm = well_csv['barrier_permeability'],\n                co2_datum    = well_csv['co2_datum'],\n                geology      = well_csv['geology'],\n           )</code></pre> <p>The processing will store the data in memory and use it to produce a hybrid geological well-sketch and a pressure-depth plot displaying the fluid pressures of each phase and the minimum horizontal stress.</p> <pre><code>#Plot sketch, pressures\nfig, (ax1, ax2) = plt.subplots(1,2, sharey=True)\nmy_well.plot_sketch(ax=ax1)\nmy_well.plot_pressure(ax=ax2)\n\nfig.tight_layout()\n</code></pre> <p>The well sketch combines both subsurface data and well engineering information. It serves as a starting point to identify the main leakage pathways and illustrate the main risks associated with the well.</p> <p>The pressure plot, besides visualizing the provided pressure scenarios, has the necessary input to run a preliminary leakage estimation based on a Darcy-based proxy. This proxy gives an estimate of leakage rates through the main barrier (deepest cement plug). The magnitude will be a function of both the transport properties assigned to the barrier and the resulting phase pressures of each scenario.</p> <p></p> <p></p>"},{"location":"code_references/well_class/models/","title":"Models","text":""},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils","title":"<code>src.WellClass.libs.models.well_model_utils</code>","text":""},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.WellHeaderModel","title":"<code>WellHeaderModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>General information about the well.</p> <p>Parameters:</p> <ul> <li> <code>well_name</code>               (<code>str</code>)           \u2013            <p>well name</p> </li> <li> <code>well_rkb</code>               (<code>float</code>)           \u2013            <p>RKB elevation</p> </li> <li> <code>sf_depth_msl</code>               (<code>float</code>)           \u2013            <p>depth of the sea floor</p> </li> <li> <code>well_td_rkb</code>               (<code>float</code>)           \u2013            <p>total depth of RKB</p> </li> <li> <code>sf_temp</code>               (<code>float</code>)           \u2013            <p>sea floor temperature</p> </li> <li> <code>geo_tgrad</code>               (<code> (float</code>)           \u2013            <p>geothermal gradient</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class WellHeaderModel(BaseModel):\n    \"\"\" General information about the well.\n\n        Args:\n            well_name (str): well name\n            well_rkb (float): RKB elevation\n            sf_depth_msl (float): depth of the sea floor\n            well_td_rkb (float): total depth of RKB\n            sf_temp (float): sea floor temperature\n            geo_tgrad  (float): geothermal gradient\n    \"\"\"\n    well_name: str\n    well_rkb: Union[int, float]\n    sf_depth_msl: Union[int, float]\n    well_td_rkb: Union[int, float]\n    sf_temp: Union[int, float]\n    geo_tgrad: Union[int, float]</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.DrillingRawModel","title":"<code>DrillingRawModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Information about the drilling intervals of the well</p> <p>Parameters:</p> <ul> <li> <code>top_rkb</code>               (<code>float</code>)           \u2013            <p>the top depth in RKB</p> </li> <li> <code>bottom_rkb</code>               (<code>float</code>)           \u2013            <p>the bottom depth in RKB </p> </li> <li> <code>diameter_in</code>               (<code>(float, str)</code>)           \u2013            <p>the diameter of the borehole in inches</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class DrillingRawModel(BaseModel):\n    \"\"\" Information about the drilling intervals of the well\n\n        Args:\n            top_rkb (float): the top depth in RKB\n            bottom_rkb (float): the bottom depth in RKB \n            diameter_in (float, str): the diameter of the borehole in inches\n    \"\"\"\n    top_rkb: Union[int, float]\n    bottom_rkb: Union[int, float]\n    diameter_in: Union[float, int, str]\n\n    @field_validator('diameter_in')\n    def diameter_in_converter(cls, v):\n        if isinstance(v, (float, int)):\n            return v\n        elif isinstance(v, str):\n            return fraction_float(v)\n        else:\n            raise ValueError('diameter_in must be a float or string')</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.DrillingModel","title":"<code>DrillingModel</code>","text":"<p>               Bases: <code>DrillingRawModel</code></p> <p>Information about the drilling intervals of the well</p> <p>Parameters:</p> <ul> <li> <code>oh_perm</code>               (<code>float</code>)           \u2013            <p>faked permeability for open-hole</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class DrillingModel(DrillingRawModel):\n    \"\"\" Information about the drilling intervals of the well\n\n        Args:\n            oh_perm (float): faked permeability for open-hole \n    \"\"\"\n    oh_perm: Union[int, float] = 10000</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.CasingCementModel","title":"<code>CasingCementModel</code>","text":"<p>               Bases: <code>DrillingRawModel</code></p> <p>Information about the casing and cementing intervals of the well</p> <p>Parameters:</p> <ul> <li> <code>toc_rkb</code>               (<code>float</code>)           \u2013            <p>top of cement-bond in RKB  </p> </li> <li> <code>boc_rkb</code>               (<code>float</code>)           \u2013            <p>bottom of cement-bond in RKB </p> </li> <li> <code>shoe</code>               (<code>bool</code>)           \u2013            <p>whether or not it has a shoe</p> </li> <li> <code>cb_perm</code>               (<code>float</code>)           \u2013            <p>permeability for cement-bond</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class CasingCementModel(DrillingRawModel):\n    \"\"\" Information about the casing and cementing intervals of the well\n\n        Args:\n          toc_rkb (float): top of cement-bond in RKB  \n          boc_rkb (float): bottom of cement-bond in RKB \n          shoe (bool): whether or not it has a shoe\n          cb_perm (float): permeability for cement-bond\n    \"\"\"\n    toc_rkb: Union[int, float]\n    boc_rkb: Union[int, float]\n    shoe: bool\n    cb_perm: Union[int, float] = 5</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.BarrierModel","title":"<code>BarrierModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Information about the barrier in the well </p> <p>Parameters:</p> <ul> <li> <code>barrier_name</code>               (<code>str</code>)           \u2013            <p>the barrier name </p> </li> <li> <code>barrier_type</code>               (<code>str</code>)           \u2013            <p>the barrier type </p> </li> <li> <code>top_rkb</code>               (<code>float</code>)           \u2013            <p>the top depth in RKB</p> </li> <li> <code>bottom_rkb</code>               (<code>float</code>)           \u2013            <p>the bottom depth in RKB</p> </li> <li> <code>barrier_perm</code>               (<code>float</code>)           \u2013            <p>permeability for the barrier</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class BarrierModel(BaseModel):\n    \"\"\" Information about the barrier in the well \n\n        Args:\n            barrier_name (str): the barrier name \n            barrier_type (str): the barrier type \n            top_rkb (float): the top depth in RKB\n            bottom_rkb (float): the bottom depth in RKB\n            barrier_perm (float): permeability for the barrier\n    \"\"\"\n    barrier_name: str\n    barrier_type: str\n    top_rkb: Union[int, float]\n    bottom_rkb: Union[int, float]\n    barrier_perm: Union[int, float] = 0.5</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.GeologyModel","title":"<code>GeologyModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The geological units encountered in the well</p> <p>Parameters:</p> <ul> <li> <code>top_rkb</code>               (<code>float</code>)           \u2013            <p>top depth in RKB</p> </li> <li> <code>geol_unit</code>               (<code>str</code>)           \u2013            <p>name </p> </li> <li> <code>reservoir_flag</code>               (<code>bool</code>)           \u2013            <p>whether or not it is considered a reservoir</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class GeologyModel(BaseModel):\n    \"\"\" The geological units encountered in the well\n\n        Args:\n            top_rkb (float): top depth in RKB\n            geol_unit (str): name \n            reservoir_flag (bool): whether or not it is considered a reservoir  \n    \"\"\"\n    top_rkb: Union[int, float]\n    geol_unit: str\n    reservoir_flag: bool</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.AssumptionsModel","title":"<code>AssumptionsModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>model for assumptions</p> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class AssumptionsModel(BaseModel):\n    \"\"\" model for assumptions\n    \"\"\"\n    pass</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.ReservoirPressureModel","title":"<code>ReservoirPressureModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for reservoir pressure</p> <p>Parameters:</p> <ul> <li> <code>depth_msl</code>               (<code>float</code>)           \u2013            <p>mean sea level depth</p> </li> <li> <code>RP1</code>               (<code>str</code>)           \u2013            <p>reservoir pressure</p> </li> <li> <code>RP2</code>               (<code>str</code>)           \u2013            <p>reservoir pressure</p> </li> <li> <code>RP3</code>               (<code>str</code>)           \u2013            <p>reservoir pressure</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class ReservoirPressureModel(BaseModel):\n    \"\"\" Model for reservoir pressure\n\n        Args:\n            depth_msl (float): mean sea level depth\n            RP1 (str): reservoir pressure\n            RP2 (str): reservoir pressure\n            RP3 (str): reservoir pressure\n    \"\"\"\n    depth_msl: Union[int, float]\n    RP1: Union[str, float, int, None] = None\n    RP2: Union[str, float, int, None] = None\n    RP3: Union[str, float, int, None] = None</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.CO2DatumModel","title":"<code>CO2DatumModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for CO2 datum. Note it is not used.</p> <p>Parameters:</p> <ul> <li> <code>co2_msl</code>               (<code>float</code>)           \u2013            <p>CO2 datum depth</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class CO2DatumModel(BaseModel):\n    \"\"\" Model for CO2 datum. Note it is not used.\n\n        Args:\n            co2_msl (float): CO2 datum depth\n    \"\"\"\n    co2_msl: Union[int, float]</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.MainBarrierModel","title":"<code>MainBarrierModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>model for main barrier</p> <p>Parameters:</p> <ul> <li> <code>barrier_name</code>               (<code>str</code>)           \u2013            <p>barrier name for proxy compute</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class MainBarrierModel(BaseModel):\n    \"\"\" model for main barrier\n\n        Args:\n            barrier_name (str): barrier name for proxy compute\n    \"\"\"\n    barrier_name: str</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.BarrierPermeabilityModel","title":"<code>BarrierPermeabilityModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>model for Barrier permeability</p> <p>Parameters:</p> <ul> <li> <code>quality</code>               (<code>str</code>)           \u2013            <p>list of quality level</p> </li> <li> <code>kv</code>               (<code>float</code>)           \u2013            <p>list of permeability values</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class BarrierPermeabilityModel(BaseModel):\n    \"\"\" model for Barrier permeability\n\n        Args:\n            quality (str): list of quality level\n            kv (float): list of permeability values\n    \"\"\"\n    quality: Union[List[str], None] = None\n    kv: List[Union[float, int]]</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model","title":"<code>src.WellClass.libs.models.well_model</code>","text":""},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model.MetaDataModel","title":"<code>MetaDataModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>meta data Args:     namespace (str): name space     name (str): can use it for project name     author (str): who made this yaml file</p> Source code in <code>src/WellClass/libs/models/well_model.py</code> <pre><code>class MetaDataModel(BaseModel):\n    \"\"\" meta data\n        Args:\n            namespace (str): name space\n            name (str): can use it for project name\n            author (str): who made this yaml file\n    \"\"\"\n    namespace: str = 'screen'\n    name: Union[str, None] = None\n    author: Union[str, None] = None</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model.WellSpec","title":"<code>WellSpec</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>specs for standard well information Args:     well_header (WellHeaderModel): well header information     drilling (list[DrillingModel]): list of drilling information     casing_cement (list[CasingCementModel]): list of casing information     barrier (list[BarrierModel]):  list of barrier information     barrier_permeability (BarrierPermeabilityModel): list of barrier permeability     geology (list[GeologyModel]): list of geology, such as formations, information     assumptions (AssumptionsModel): misceleaneous information     co2_datum (CO2DatumModel): co2 datum</p> Source code in <code>src/WellClass/libs/models/well_model.py</code> <pre><code>class WellSpec(BaseModel):\n    \"\"\" specs for standard well information\n        Args:\n            well_header (WellHeaderModel): well header information\n            drilling (list[DrillingModel]): list of drilling information\n            casing_cement (list[CasingCementModel]): list of casing information\n            barrier (list[BarrierModel]):  list of barrier information\n            barrier_permeability (BarrierPermeabilityModel): list of barrier permeability\n            geology (list[GeologyModel]): list of geology, such as formations, information\n            assumptions (AssumptionsModel): misceleaneous information\n            co2_datum (CO2DatumModel): co2 datum \n    \"\"\"\n    well_header: WellHeaderModel\n    drilling: Union[List[DrillingModel], None] = None\n    casing_cement: Union[List[CasingCementModel], None] = None\n    barriers: Union[List[BarrierModel], None] = None\n    barrier_permeability: Union[BarrierPermeabilityModel, None] = None\n    geology: Union[List[GeologyModel], None] = None\n    assumptions: Union[AssumptionsModel, None] = None\n    co2_datum: Union[float, int]                                       # CO2DatumModel</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model.WellPressureSpec","title":"<code>WellPressureSpec</code>","text":"<p>               Bases: <code>WellSpec</code></p> <p>extra specs for pressure information Args:     reservoir_pressure (ReservoirPressureModel): general reservoir pressure information     main_barrier (str): main barrier name to compute pressure</p> Source code in <code>src/WellClass/libs/models/well_model.py</code> <pre><code>class WellPressureSpec(WellSpec):\n    \"\"\" extra specs for pressure information\n        Args:\n            reservoir_pressure (ReservoirPressureModel): general reservoir pressure information\n            main_barrier (str): main barrier name to compute pressure\n    \"\"\"\n    reservoir_pressure: Union[ReservoirPressureModel, None] = None\n    main_barrier: Union[str, None] = None</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model.WellModel","title":"<code>WellModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>model including all parameters Args:     apiVersion (str): current version of this yaml format     kind (str): for GaP     metadata (MetaDataModel): miscelaneous data     spec (WellPressureSpec): well specification</p> Source code in <code>src/WellClass/libs/models/well_model.py</code> <pre><code>class WellModel(BaseModel):\n    \"\"\" model including all parameters\n        Args:\n            apiVersion (str): current version of this yaml format\n            kind (str): for GaP\n            metadata (MetaDataModel): miscelaneous data\n            spec (WellPressureSpec): well specification\n    \"\"\"\n    apiVersion: str = 'well/v0.1'\n    kind: str = 'Well'\n    metadata: Union[MetaDataModel, None] = None\n    spec: WellPressureSpec</code></pre>"},{"location":"code_references/well_class/well_class/","title":"Well class","text":""},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_raw","title":"<code>src.WellClass.libs.well_class.well_raw</code>","text":"<p>How to initialize:</p> <pre><code>import well_class\n\nINDATA          = &lt;path to a csv-file with the well-data&gt;\n\n#Reads the csv-file and organize the data into a dict of dataframes\n\nwell_df         = well_class.csv_parser(INDATA)                          </code></pre> <p>Then the class is initialized with a lot of explicit calls. (Bad structure - should been done in one go: <code>mywell = Well(INDATA)</code>)</p> <pre><code>mywell          = well_class.Well(\n                       header       = well_df['well_header'],\n                       reservoir_P  = well_df['reservoir_pressure'],\n                       drilling     = well_df['drilling'],\n                       casings      = well_df['casing_cement'],\n                       barriers     = well_df['barriers'],\n                       geology      = well_df['geology'],\n                       main_barrier = well_df['main_barrier'],\n                       barrier_perm = well_df['barrier_permeability'],\n                       co2_datum    = well_df['co2_datum']\n                   )</code></pre> <p>Now additional functionalities that can be explicitely called are  <pre><code>   .plot_pt()\n\n   .plot_pressure()  + plt.show()\n\n   .plot_sketch()    + plt.show()</code></pre></p>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_raw.WellRaw","title":"<code>WellRaw</code>  <code>dataclass</code>","text":"<p>Basic user input well information</p> <p>Parameters:</p> <ul> <li> <code>header</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>well header</p> </li> <li> <code>drilling</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>drilling well</p> </li> <li> <code>casings</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>well casing</p> </li> <li> <code>barriers</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>barrier information</p> </li> <li> <code>barrier_perm</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>barrier permeabilities</p> </li> <li> <code>geology</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>gelogical formation</p> </li> <li> <code>co2_datum</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>co2 datum value</p> </li> </ul> Source code in <code>src/WellClass/libs/well_class/well_raw.py</code> <pre><code>@dataclass              # @dataclass(kw_only=True)\nclass WellRaw:\n    \"\"\" Basic user input well information\n\n        Args:\n            header (dict): well header\n            drilling (dict): drilling well\n            casings (dict): well casing\n            barriers (dict): barrier information\n            barrier_perm (dict): barrier permeabilities\n            geology (dict): gelogical formation\n            co2_datum (float): co2 datum value\n    \"\"\"\n    header        : dict = None\n    drilling      : dict = None\n    casings       : dict = None\n    barriers      : dict = None\n    barrier_perm  : dict = None\n    geology       : dict = None\n    co2_datum     : Union[float, int] = None\n    inventory     : dict = None\n\n    def __post_init__(self):\n        \"\"\" compute basic well information\n        \"\"\"\n        self._check_inventory()\n        self._process_drilling()\n        self._process_casings()\n        self._process_barriers()\n        self._process_geology()\n\n    def _check_inventory(self):\n\n        \"\"\"\n        process to keep track of what has been declared as input.\n        \"\"\"\n        self.inventory = dict()\n\n        self.inventory['drilling'] = True\n        self.inventory['casings']  = True\n        self.inventory['barriers'] = True\n        self.inventory['geology'] = True\n\n        if self.drilling == None:\n            print('No drilling table declared.')\n            \"\"\"\n            If no drilling table is declared, ignore the casings table as well\n            \"\"\"\n            self.inventory['drilling'] = False\n            self.inventory['casings'] = False\n\n        if self.casings == None:\n            print('No casings table declared.')\n            self.inventory['casings'] = False\n\n        if self.barriers == None:\n            print('No barriers table declared.')\n            self.inventory['barriers'] = False\n\n        if self.geology == None:\n            print('No geology table declared.')\n            self.inventory['geology'] = False\n\n\n\n\n\n    def _process_drilling(self):\n\n        if not self.inventory['drilling']:\n            \"\"\"\n            If no drilling table is declared, create a dummy well with info from the header\n            \"\"\"\n            _well_rkb = self.header['well_rkb']\n            _well_td_rkb = self.header['well_td_rkb']\n            _sf_depth_msl = self.header['sf_depth_msl']\n\n            self.drilling = [{'top_rkb': _sf_depth_msl + _well_rkb, 'bottom_rkb': _well_td_rkb, 'diameter_in': 17.5, 'oh_perm': 10000}] \n\n        drilling_df = pd.DataFrame(self.drilling)\n\n        drilling_df['diameter_m'] = drilling_df['diameter_in'] * scipy.constants.inch       #0.0254\n        drilling_df['top_msl']    = drilling_df['top_rkb'] - self.header['well_rkb']\n        drilling_df['bottom_msl'] = drilling_df['bottom_rkb'] - self.header['well_rkb']\n\n        # validate drilling\n        valid_drilling(drilling_df)\n\n        self.drilling = drilling_df.to_dict()\n\n    def _process_casings(self):\n\n        if not self.inventory['casings']:\n            \"\"\"\n            If no casings table is declared, create a dummy well with info from the header\n            \"\"\"\n            _well_rkb = self.header['well_rkb']\n            _well_td_rkb = self.header['well_td_rkb']\n            _sf_depth_msl = self.header['sf_depth_msl']\n            _diameter_in = pd.DataFrame(self.drilling)['diameter_in'].min() - 2\n\n            self.casings = [{'top_rkb': _sf_depth_msl + _well_rkb,\n                             'bottom_rkb': _well_td_rkb,\n                             'diameter_in': _diameter_in,\n                             'toc_rkb': _sf_depth_msl + _well_rkb,\n                             'boc_rkb': _well_td_rkb,\n                             'shoe': True,\n                             'cb_perm': 0.05}]\n\n\n        casings_df = pd.DataFrame(self.casings)\n\n        casings_df['diameter_m'] = casings_df['diameter_in'] * scipy.constants.inch         #0.0254\n        casings_df['top_msl']    = casings_df['top_rkb']    - self.header['well_rkb']\n        casings_df['bottom_msl'] = casings_df['bottom_rkb'] - self.header['well_rkb']\n        casings_df['toc_msl']    = casings_df['toc_rkb']    - self.header['well_rkb']\n        casings_df['boc_msl']    = casings_df['boc_rkb']    - self.header['well_rkb']\n\n        # validate casings\n        valid_casings(casings_df)\n\n        self.casings = casings_df.to_dict()\n\n    def _process_barriers(self):\n\n        if self.inventory['barriers']:\n\n            barriers_df = pd.DataFrame(self.barriers)\n\n            barriers_df['top_msl']    = barriers_df['top_rkb']    - self.header['well_rkb']\n            barriers_df['bottom_msl'] = barriers_df['bottom_rkb'] - self.header['well_rkb']\n\n            # barriers_df.set_index('barrier_name', inplace=True)\n            self.barriers = barriers_df.to_dict()\n\n    def _process_geology(self):\n\n        if self.inventory['barriers']:\n\n            geology_df = pd.DataFrame(self.geology)\n\n            geology_df = geology_df.dropna(how='all')\n            geology_df = geology_df.reset_index(drop=True)\n\n            geology_df['top_msl']  = geology_df['top_rkb'] - self.header['well_rkb']\n            geology_df['base_msl'] = geology_df['top_msl'] - geology_df['top_msl'].diff(periods=-1)\n            geology_df.loc[geology_df.index.max(), 'base_msl'] = self.header['well_td_rkb'] - self.header['well_rkb']\n\n            self.geology = geology_df.to_dict()\n\n    @property\n    def to_json(self):\n        return json.dumps(self.__dict__, indent=4)</code></pre>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_raw.WellRaw.__post_init__","title":"<code>__post_init__()</code>","text":"<p>compute basic well information</p> Source code in <code>src/WellClass/libs/well_class/well_raw.py</code> <pre><code>def __post_init__(self):\n    \"\"\" compute basic well information\n    \"\"\"\n    self._check_inventory()\n    self._process_drilling()\n    self._process_casings()\n    self._process_barriers()\n    self._process_geology()</code></pre>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_class","title":"<code>src.WellClass.libs.well_class.well_class</code>","text":"<p>How to initialize:</p> <pre><code>import well_class\n\nINDATA          = &lt;path to a csv-file with the well-data&gt;\n\n#Reads the csv-file and organize the data into a dict of dataframes\n\nwell_df         = well_class.csv_parser(INDATA)                          </code></pre> <p>Then the class is initialized with a lot of explicit calls. (Bad structure - should been done in one go: <code>mywell = Well(INDATA)</code>) <pre><code>mywell          = well_class.Well(\n                       header       = well_df['well_header'],\n                       reservoir_P  = well_df['reservoir_pressure'],\n                       drilling     = well_df['drilling'],\n                       casings      = well_df['casing_cement'],\n                       barriers     = well_df['barriers'],\n                       geology      = well_df['geology'],\n                       main_barrier = well_df['main_barrier'],\n                       barrier_perm = well_df['barrier_permeability'],\n                       co2_datum    = well_df['co2_datum']\n                   )</code></pre></p> <p>Now additional functionalities that can be explicitely called are  <pre><code>   .plot_pt()\n\n   .plot_pressure()  + plt.show()\n\n   .plot_sketch()    + plt.show()</code></pre></p>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_class.Well","title":"<code>Well</code>  <code>dataclass</code>","text":"<p>               Bases: <code>WellRaw</code></p> <p>This contains not only the basic well information but also its computed information.</p> <p>Parameters:</p> <ul> <li> <code>borehole</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>for borehole information</p> </li> <li> <code>cement_bond</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>contains information about cement bond</p> </li> <li> <code>annulus</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>gap between casing and openhole</p> </li> <li> <code>barriers_mod</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>extra information about barriers</p> </li> <li> <code>barriers_names</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>reorgainze barrier names</p> </li> </ul> Source code in <code>src/WellClass/libs/well_class/well_class.py</code> <pre><code>@dataclass              # @dataclass(kw_only=True)\nclass Well(WellRaw):\n    \"\"\" This contains not only the basic well information but also its computed information.\n\n        Args:\n            borehole (dict): for borehole information\n            cement_bond (dict): contains information about cement bond\n            annulus (dict): gap between casing and openhole\n            barriers_mod (dict): extra information about barriers\n            barriers_names (dict): reorgainze barrier names\n    \"\"\"\n    borehole      : dict = None\n    cement_bond   : dict = None\n    annulus       : dict = None\n    barriers_mod  : dict = None\n    barriers_names: dict = None\n\n    def __post_init__(self):\n\n        super().__post_init__()\n\n        self._compute_well()\n\n    def _compute_well(self):\n        \"\"\" compute extra well information\n        \"\"\"\n\n        self.borehole = compute_borehole(self.casings, self.drilling)\n        self.cement_bond = compute_cement_bond(self.casings, self.drilling)\n        self.annulus= compute_annulus(self.casings, self.drilling)\n\n        if self.inventory['barriers']:\n            self.barriers_mod = compute_barriers_diam(self.barriers, self.borehole)\n            self.barriers_names = get_barriers_names(self.barriers_mod)\n\n    def compute_barrier_props(self, barrier_name: str) -&gt; dict:\n        \"\"\" Compute barrier geometrical information\n\n            Args:\n               barrier_name (str): barrier name \n        \"\"\"\n\n        # for convenience\n        barriers_mod = self.barriers_mod\n        barriers_names = self.barriers_names\n\n        # properties\n        barrier_props = {}\n\n        # height/depth\n        barrier_h_d = get_barrier_height_and_depth(barriers_mod, barriers_names, barrier_name)\n        barrier_props.update(barrier_h_d)\n\n        # radius\n        barrier_r = get_barrier_radius(barriers_mod, barriers_names, barrier_name)\n        barrier_props.update(barrier_r)\n\n        return barrier_props\n\n    @property\n    def to_json(self):\n        return json.dumps(self.__dict__, indent=4)</code></pre>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_class.Well.compute_barrier_props","title":"<code>compute_barrier_props(barrier_name: str) -&gt; dict</code>","text":"<p>Compute barrier geometrical information</p> <p>Parameters:</p> <ul> <li> <code>barrier_name</code>               (<code>str</code>)           \u2013            <p>barrier name</p> </li> </ul> Source code in <code>src/WellClass/libs/well_class/well_class.py</code> <pre><code>def compute_barrier_props(self, barrier_name: str) -&gt; dict:\n    \"\"\" Compute barrier geometrical information\n\n        Args:\n           barrier_name (str): barrier name \n    \"\"\"\n\n    # for convenience\n    barriers_mod = self.barriers_mod\n    barriers_names = self.barriers_names\n\n    # properties\n    barrier_props = {}\n\n    # height/depth\n    barrier_h_d = get_barrier_height_and_depth(barriers_mod, barriers_names, barrier_name)\n    barrier_props.update(barrier_h_d)\n\n    # radius\n    barrier_r = get_barrier_radius(barriers_mod, barriers_names, barrier_name)\n    barrier_props.update(barrier_r)\n\n    return barrier_props</code></pre>"},{"location":"code_references/well_class/well_pressure/","title":"Well pressure","text":""},{"location":"code_references/well_class/well_pressure/#src.WellClass.libs.well_pressure.pressure","title":"<code>src.WellClass.libs.well_pressure.pressure</code>","text":""},{"location":"code_references/well_class/well_pressure/#src.WellClass.libs.well_pressure.pressure.Pressure","title":"<code>Pressure</code>  <code>dataclass</code>","text":"<p>This is used to compute leakeage rate of legacy well</p> <p>Parameters:</p> <ul> <li> <code>header</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>well header</p> </li> <li> <code>reservoir_P</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>reservoir pressure</p> </li> <li> <code>co2_datum</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>co2 datum depth</p> </li> <li> <code>pvt_path</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>directory where PVT files are located.</p> </li> </ul> Source code in <code>src/WellClass/libs/well_pressure/pressure.py</code> <pre><code>@dataclass              # @dataclass(kw_only=True)\nclass Pressure:\n    \"\"\" This is used to compute leakeage rate of legacy well\n\n        Args:\n            header (dict): well header\n            reservoir_P (dict): reservoir pressure\n            co2_datum (float): co2 datum depth\n            pvt_path (str): directory where PVT files are located.            \n    \"\"\"\n    header          : dict = None\n    reservoir_P     : dict = None    \n    co2_datum       : dict = None\n    pvt_path        : Union[str, Path] = None\n    barriers        : dict = None\n    max_pressure_pos: Union[dict, list, float, int] = None\n    pressure_scenarios : dict = None\n    mixture_name   :  str = None\n    mixture_composition   :  str = None\n\n    def __post_init__(self):\n        self._get_mixture_info()\n        self.init_pressure_curves()\n        self.check_init_pressure()\n        self._init_CO2_pressures_table()\n        self.check_scenarios_from_input()\n\n\n    # TODO(hzh): non-pure function!!!\n    def _get_mixture_info(self):\n\n        if isinstance(self.pvt_path, str):\n            pvt_path = Path(self.pvt_path)\n        else:\n            pvt_path = self.pvt_path\n\n        with open(pvt_path / \"metadata.json\", \"r\") as file:\n            mixture_info = json.load(file)\n\n        self.mixture_name = mixture_info['name']\n        self.mixture_composition = mixture_info['composition']\n        print(f'Computing pressures for {self.mixture_name} ({self.mixture_composition})')\n\n\n    def init_pressure_curves(self):\n        '''\n        Initiates Pressure table for the wellbore\n        By default creates a hydrostatic gradient curve and a Sh min curve\n        '''\n\n        #Calculate depth, temp(depth) hydrostatic_pressure(depth), H2ORHO(depth for hydrostatic pressure)\n        init_curves = get_hydrostatic_P(self.header, pvt_path=self.pvt_path) \n\n        #Include Minimum horizontal stress\n        init_curves = _get_shmin(self.header, init_curves)\n\n        #Store tables in main pressure_CO2 table \n        self.init_curves = init_curves\n\n    def check_init_pressure(self):\n        '''\n        Calculates hydrostatic pressure at reservoir_P['depth_msl'] and stores it in reservoir_P['hydrostatic_pressure']\n\n        reservoir_pressure\t\t\n        depth_msl\tRP1\tRP2\n        2238\t\t        20\n\n        then P_init['depth_msl'] is the reference depth 2238\n\n        Also delta-pressures RP1 and RP2 are read and used later for leakage calculations. (self.reservoir_P[])\n\n        Note: The interpretation of the numbers set for RP1 and RP2 is a bit unclear. \n              RP means reservoir pressure - but for the current implementation \n              it is interpreted as delta pressure: delta wrt hydrostatic pressure. \n              Initial implementation had the possibility to have absolute pressure AND a delta-pressure. But the delta-pressure had to be \n              given as a string \"+ 20\" or \"- 15\". Bit the + and - tended to create problems. \n              So alternatively one could distingwuish between RP and DP  if it is important to give in absolute pressure as well.\n              But the most interesting input IS actually the change in pressure compared with hydrostatic pressure.\n\n        '''\n        # If no reservoir pressure is given, then we assume the reservoir is at the CO2 datum\n        if self.reservoir_P is None:\n            self.reservoir_P = {'depth_msl': self.co2_datum}\n\n        #Get initial pressure table from reservoir_P dictionary\n        P_init = self.reservoir_P\n\n        # Get reference depth from reservoir_P, e.g. top reservoir\n        ref_z        = P_init['depth_msl']                       \n\n\n        #Hydrostatic pressure at reference depth (ref_z)\n        ref_p        = np.interp(ref_z, self.init_curves['depth_msl'], self.init_curves[ 'hs_p'])\n        print(f\"Hydrostatic pressure at reference depth {ref_z:.0f} is {ref_p:.2f}\")\n\n        #Store value in reservoir_P table\n        self.reservoir_P['hydrostatic_pressure'] = float(ref_p)\n\n\n\n    def _init_pressure_scenarios_dict(self):\n        '''\n        Returns a dictionary with default values for a new pressure scenario\n        '''\n        # Define the default dictionary\n        default_dict = {\n            'name': None,\n            'z_MSAD': None,\n            'from_resrvr': None,\n            'p_MSAD': None,\n            'p_resrv': None,\n            'z_resrv': None,\n            'p_delta': None\n        }\n\n        self.pressure_scenarios = defaultdict(lambda: default_dict.copy())\n\n    def _init_CO2_pressures_table(self):\n         #Define and assign a multiindex that groups columns generic for all scenarios: depth_msl, temp, hs_p, RHOH2O and Shmin \n        index_init = pd.MultiIndex.from_product([['init'], self.init_curves.columns])\n        self.pressure_CO2 = self.init_curves.copy()\n        self.pressure_CO2.columns = index_init\n\n\n    def check_scenarios_from_input(self):\n        '''\n        Reads input scenarios and creates a dictionary of scenarios to compute pressures for\n        '''\n        #Initialize dictionary of scenarios\n        self._init_pressure_scenarios_dict()\n\n        MAX_PRESSURE_NAME = 'max_p'\n\n        #Get hydrostatic pressure at reservoir depth\n        ref_p = self.reservoir_P['hydrostatic_pressure']\n\n        #Compute number of scenarios\n        n_scenarios = max(len(self.reservoir_P)-2, 0)\n\n        #Initialize scenario counter\n        scenario_counter = 0\n\n        #If no scenarios are given, then we have at least one scenario: hydrostatic pressure\n        self._add_hydrostatic_scenario(scenario_counter, ref_p)\n\n        #Increment scenario counter\n        scenario_counter += 1\n\n        #Iterate over input scenarios\n        if n_scenarios &gt; 0:\n            scenario_counter = self._add_input_scenarios(scenario_counter, ref_p)\n\n        #Iterate over maximum pressure scenarios\n        if not self.max_pressure_pos is None:\n            self._add_max_pressure_scenarios(scenario_counter, MAX_PRESSURE_NAME)\n\n\n\n    def _add_hydrostatic_scenario(self, scenario_counter, ref_p):\n        '''\n        Include hydrostatic pressure scenario to pressure_scenarios dictionary\n        '''\n        self.pressure_scenarios[scenario_counter]['name'] = 'hydrostatic'\n        self.pressure_scenarios[scenario_counter]['p_resrv'] = ref_p\n        self.pressure_scenarios[scenario_counter]['from_resrvr'] = True\n        self.pressure_scenarios[scenario_counter]['z_resrv'] = self.reservoir_P['depth_msl']\n        self.pressure_scenarios[scenario_counter]['p_delta'] = 0\n\n        sc_pressure = self._compute_scenario_profiles(self.pressure_scenarios[scenario_counter])\n\n        self.pressure_scenarios[scenario_counter]['p_MSAD'] = sc_pressure.p_MSAD\n        self.pressure_scenarios[scenario_counter]['z_MSAD'] = sc_pressure.z_MSAD\n\n    def _add_input_scenarios(self, scenario_counter, ref_p):\n        '''\n        If more scenarios are included in input data, then they are added to the pressure_scenarios dictionary\n        '''\n        keys_to_skip = {'depth_msl', 'hydrostatic_pressure'}\n        first_as_hydrostatic = False\n\n        for sc_name, sc_pressure in self.reservoir_P.items():\n            if sc_name in keys_to_skip:\n                continue\n\n            if sc_pressure is None or (isinstance(sc_pressure, float) and math.isnan(sc_pressure)):\n                if not first_as_hydrostatic:\n\n                    self.pressure_scenarios[0]['name'] = sc_name\n\n\n                    self.pressure_CO2.columns = self.pressure_CO2.columns.set_levels(\n                        self.pressure_CO2.columns.levels[0].str.replace('hydrostatic', sc_name), level=0)\n\n                    first_as_hydrostatic = True\n                continue\n\n            magnitude = self._parse_pressure_magnitude(sc_pressure)\n            p_resrv = ref_p + magnitude\n            self.pressure_scenarios[scenario_counter]['name'] = sc_name\n            self.pressure_scenarios[scenario_counter]['p_resrv'] = p_resrv\n            self.pressure_scenarios[scenario_counter]['z_resrv'] = self.reservoir_P['depth_msl']\n            self.pressure_scenarios[scenario_counter]['from_resrvr'] = True\n            self.pressure_scenarios[scenario_counter]['p_delta'] = magnitude\n\n            sc_pressure = self._compute_scenario_profiles(self.pressure_scenarios[scenario_counter])\n\n            self.pressure_scenarios[scenario_counter]['p_MSAD'] = sc_pressure.p_MSAD\n            self.pressure_scenarios[scenario_counter]['z_MSAD'] = sc_pressure.z_MSAD\n\n\n\n            scenario_counter += 1\n\n        return scenario_counter\n\n    def _parse_pressure_magnitude(self, sc_pressure):\n        '''\n        Parses pressure magnitude from string to float\n        '''\n        try:\n            if isinstance(sc_pressure, str):\n                sc_pressure = sc_pressure.replace(\" \", \"\")\n            return float(sc_pressure)\n        except Exception:\n            return sc_pressure\n\n    def _add_max_pressure_scenarios(self, scenario_counter, MAX_PRESSURE_NAME):\n        '''\n        Includes maximum pressure scenarios in the pressure_scenarios dictionary\n        Maximum pressure scenarios are calculated from the Shmin values at specific depths above the reservoir\n        '''\n        # Determine the iterable based on the type of self.max_pressure_pos\n        # Check if max_pressure_pos is a dictionary of barriers\n        if isinstance(self.max_pressure_pos, dict):  \n            print(f'max_pressure_pos is a dictionary of barriers')\n            iterable = [(self.max_pressure_pos['bottom_msl'][idx], key) for idx, key in self.max_pressure_pos['barrier_name'].items()]\n\n        # Check if max_pressure_pos is a depth value or a list of depths\n        elif isinstance(self.max_pressure_pos, (list, float, int)):\n            print(f'max_pressure_pos is a value')\n            if isinstance(self.max_pressure_pos, (float, int)):  # Make it a list with one element\n                self.max_pressure_pos = [self.max_pressure_pos]\n            iterable = [(depth, f\"at_{int(depth)}\") for depth in self.max_pressure_pos]\n        else:\n            raise ValueError(\"Invalid type for max_pressure_pos\")\n\n        # Process the iterable\n        for barr_depth, key in iterable:\n            sc_name = f\"{MAX_PRESSURE_NAME}_{key}\"\n            self.pressure_scenarios[scenario_counter]['name'] = sc_name\n            self.pressure_scenarios[scenario_counter]['z_MSAD'] = barr_depth\n            self.pressure_scenarios[scenario_counter]['from_resrvr'] = False\n\n            sc_pressure = self._compute_scenario_profiles(self.pressure_scenarios[scenario_counter])\n\n            self.pressure_scenarios[scenario_counter]['p_MSAD'] = sc_pressure.p_MSAD\n            self.pressure_scenarios[scenario_counter]['p_resrv'] = sc_pressure.p_resrv\n            self.pressure_scenarios[scenario_counter]['z_resrv'] = sc_pressure.z_resrv \n            self.pressure_scenarios[scenario_counter]['p_delta'] = sc_pressure.p_delta\n\n            scenario_counter += 1\n\n\n    def _compute_scenario_profiles(self, pressure_scenario: dict):\n        #Retrieve pressure, temperature and density fields for CO2 and H2O\n        pvt_T, pvt_P, pvt_RHO_CO2, pvt_RHO_H2O =  get_pvt(self.pvt_path)        \n\n        #An interpolator. Used later to look-up densities given pressure p and temperature t\n        get_rho_h2o = RectBivariateSpline(pvt_P, pvt_T, pvt_RHO_H2O)\n        get_rho_co2 = RectBivariateSpline(pvt_P, pvt_T, pvt_RHO_CO2)\n\n        sc_pressure = FluidP_scenario(**pressure_scenario)\n        sc_pressure.compute_pressure_profile(init_table = self.init_curves,\n                                             well_header = self.header,\n                                             rho_co2_getter = get_rho_co2,\n                                             rho_h2o_getter = get_rho_h2o,\n                                             z_co2_datum = self.co2_datum)\n\n\n\n        self._merge_scenario_profiles(sc_pressure)\n\n        return sc_pressure\n\n\n\n\n    def _merge_scenario_profiles(self, sc_pressure: FluidP_scenario):\n\n        #Drop repeated columns\n        sc_pressure.P_table = sc_pressure.P_table.drop(columns = self.pressure_CO2['init'].columns)\n\n        #Setup multiindex\n        index_table = pd.MultiIndex.from_product([[sc_pressure.name], sc_pressure.P_table.columns])\n        sc_pressure.P_table.columns = index_table\n\n        #Concatenate init table with scenario table\n        self.pressure_CO2 = pd.concat([self.pressure_CO2, sc_pressure.P_table], axis= 1)\n\n\n\n\n    def compute_barrier_leakage(self, well: Well, barrier_name: str) -&gt; pd.DataFrame:\n        \"\"\" Compute leakage rate from the given barrier\n\n            Args:\n                well (Well): well information\n                barrier_name (str): barrier to check the leakage rate\n        \"\"\"\n        if well.inventory['barriers']:\n            # for convenience\n            barrier_perm = well.barrier_perm\n\n            # barrier geometries\n            barrier_props = well.compute_barrier_props(barrier_name)\n\n            # Estimate CO2 leakage in [tons/day] after a trancient period\n            barrier_leakage = compute_barrier_leakage(barrier_perm, self.pressure_scenarios, self.pressure_CO2, barrier_props)\n\n            return barrier_leakage\n\n        else:\n            print(f'No barriers declared in well {well.header[\"well_name\"]}')\n\n    def create_pressure_scenario(self, name: str = None, z_MSAD: float = None, from_resrvr: bool = None, p_MSAD: float = None, p_resrv: float = None, z_resrv: float = None, p_delta: float = None):\n        scenario_counter = len(self.pressure_scenarios)\n        self.pressure_scenarios[scenario_counter] = {\n            'name': name,\n            'z_MSAD': z_MSAD,\n            'from_resrvr': from_resrvr,\n            'p_MSAD': p_MSAD,\n            'p_resrv': p_resrv,\n            'z_resrv': z_resrv,\n            'p_delta': p_delta\n        }\n\n        if name is None:\n            raise ValueError(\"The 'name' parameter is required.\")\n\n        if from_resrvr is None:\n            raise ValueError(\"The 'from_resrvr' parameter is required.\")\n\n        if from_resrvr:\n            if p_delta is None and (p_resrv is None or z_resrv is None):\n                raise ValueError(\"If 'from_resrvr' is True, you must provide either 'p_delta' or both 'p_resrv' and 'z_resrv'.\")\n\n            if p_resrv is not None and z_resrv is not None:\n                # Interpolate hydrostatic pressure at z_resrv\n                hydrostatic_pressure = np.interp(z_resrv, self.init_curves['depth_msl'], self.init_curves['hs_p'])\n\n                self.pressure_scenarios[scenario_counter]['p_delta'] = p_resrv - hydrostatic_pressure\n            elif p_delta is not None and z_resrv is not None:\n                # Interpolate hydrostatic pressure at z_resrv\n                hydrostatic_pressure = np.interp(z_resrv, self.init_curves['depth_msl'], self.init_curves['hs_p'])\n\n\n                self.pressure_scenarios[scenario_counter]['p_resrv'] = hydrostatic_pressure + p_delta\n\n            elif p_delta is not None:\n                # Use self.co2_datum as z_resrv\n                print('TESTING')\n                z_resrv = self.co2_datum\n                hydrostatic_pressure = np.interp(z_resrv, self.init_curves['depth_msl'], self.init_curves['hs_p'])\n                self.pressure_scenarios[scenario_counter]['p_resrv'] = hydrostatic_pressure + p_delta\n                self.pressure_scenarios[scenario_counter]['z_resrv'] = z_resrv\n            else:\n                raise ValueError(\"Invalid combination of parameters for 'from_resrvr' = True.\")\n        else:\n            if z_MSAD is None:\n                raise ValueError(\"If 'from_resrvr' is False, you must provide 'z_MSAD'.\")\n\n\n        sc_pressure = self._compute_scenario_profiles(self.pressure_scenarios[scenario_counter])\n\n        self.pressure_scenarios[scenario_counter]['p_MSAD'] = sc_pressure.p_MSAD\n        self.pressure_scenarios[scenario_counter]['z_MSAD'] = sc_pressure.z_MSAD\n        self.pressure_scenarios[scenario_counter]['p_delta'] = sc_pressure.p_delta\n        self.pressure_scenarios[scenario_counter]['p_resrv'] = sc_pressure.p_resrv\n        self.pressure_scenarios[scenario_counter]['z_resrv'] = sc_pressure.z_resrv\n\n    @property\n    def to_json(self):\n        return json.dumps(self.__dict__, indent=4)</code></pre>"},{"location":"code_references/well_class/well_pressure/#src.WellClass.libs.well_pressure.pressure.Pressure.init_pressure_curves","title":"<code>init_pressure_curves()</code>","text":"<p>Initiates Pressure table for the wellbore By default creates a hydrostatic gradient curve and a Sh min curve</p> Source code in <code>src/WellClass/libs/well_pressure/pressure.py</code> <pre><code>def init_pressure_curves(self):\n    '''\n    Initiates Pressure table for the wellbore\n    By default creates a hydrostatic gradient curve and a Sh min curve\n    '''\n\n    #Calculate depth, temp(depth) hydrostatic_pressure(depth), H2ORHO(depth for hydrostatic pressure)\n    init_curves = get_hydrostatic_P(self.header, pvt_path=self.pvt_path) \n\n    #Include Minimum horizontal stress\n    init_curves = _get_shmin(self.header, init_curves)\n\n    #Store tables in main pressure_CO2 table \n    self.init_curves = init_curves</code></pre>"},{"location":"code_references/well_class/well_pressure/#src.WellClass.libs.well_pressure.pressure.Pressure.check_init_pressure","title":"<code>check_init_pressure()</code>","text":"<p>Calculates hydrostatic pressure at reservoir_P['depth_msl'] and stores it in reservoir_P['hydrostatic_pressure']</p> <p>reservoir_pressure             depth_msl       RP1     RP2 2238                    20</p> <p>then P_init['depth_msl'] is the reference depth 2238</p> <p>Also delta-pressures RP1 and RP2 are read and used later for leakage calculations. (self.reservoir_P[])</p> The interpretation of the numbers set for RP1 and RP2 is a bit unclear. <p>RP means reservoir pressure - but for the current implementation  it is interpreted as delta pressure: delta wrt hydrostatic pressure.  Initial implementation had the possibility to have absolute pressure AND a delta-pressure. But the delta-pressure had to be  given as a string \"+ 20\" or \"- 15\". Bit the + and - tended to create problems.  So alternatively one could distingwuish between RP and DP  if it is important to give in absolute pressure as well. But the most interesting input IS actually the change in pressure compared with hydrostatic pressure.</p> Source code in <code>src/WellClass/libs/well_pressure/pressure.py</code> <pre><code>def check_init_pressure(self):\n    '''\n    Calculates hydrostatic pressure at reservoir_P['depth_msl'] and stores it in reservoir_P['hydrostatic_pressure']\n\n    reservoir_pressure\t\t\n    depth_msl\tRP1\tRP2\n    2238\t\t        20\n\n    then P_init['depth_msl'] is the reference depth 2238\n\n    Also delta-pressures RP1 and RP2 are read and used later for leakage calculations. (self.reservoir_P[])\n\n    Note: The interpretation of the numbers set for RP1 and RP2 is a bit unclear. \n          RP means reservoir pressure - but for the current implementation \n          it is interpreted as delta pressure: delta wrt hydrostatic pressure. \n          Initial implementation had the possibility to have absolute pressure AND a delta-pressure. But the delta-pressure had to be \n          given as a string \"+ 20\" or \"- 15\". Bit the + and - tended to create problems. \n          So alternatively one could distingwuish between RP and DP  if it is important to give in absolute pressure as well.\n          But the most interesting input IS actually the change in pressure compared with hydrostatic pressure.\n\n    '''\n    # If no reservoir pressure is given, then we assume the reservoir is at the CO2 datum\n    if self.reservoir_P is None:\n        self.reservoir_P = {'depth_msl': self.co2_datum}\n\n    #Get initial pressure table from reservoir_P dictionary\n    P_init = self.reservoir_P\n\n    # Get reference depth from reservoir_P, e.g. top reservoir\n    ref_z        = P_init['depth_msl']                       \n\n\n    #Hydrostatic pressure at reference depth (ref_z)\n    ref_p        = np.interp(ref_z, self.init_curves['depth_msl'], self.init_curves[ 'hs_p'])\n    print(f\"Hydrostatic pressure at reference depth {ref_z:.0f} is {ref_p:.2f}\")\n\n    #Store value in reservoir_P table\n    self.reservoir_P['hydrostatic_pressure'] = float(ref_p)</code></pre>"},{"location":"code_references/well_class/well_pressure/#src.WellClass.libs.well_pressure.pressure.Pressure.check_scenarios_from_input","title":"<code>check_scenarios_from_input()</code>","text":"<p>Reads input scenarios and creates a dictionary of scenarios to compute pressures for</p> Source code in <code>src/WellClass/libs/well_pressure/pressure.py</code> <pre><code>def check_scenarios_from_input(self):\n    '''\n    Reads input scenarios and creates a dictionary of scenarios to compute pressures for\n    '''\n    #Initialize dictionary of scenarios\n    self._init_pressure_scenarios_dict()\n\n    MAX_PRESSURE_NAME = 'max_p'\n\n    #Get hydrostatic pressure at reservoir depth\n    ref_p = self.reservoir_P['hydrostatic_pressure']\n\n    #Compute number of scenarios\n    n_scenarios = max(len(self.reservoir_P)-2, 0)\n\n    #Initialize scenario counter\n    scenario_counter = 0\n\n    #If no scenarios are given, then we have at least one scenario: hydrostatic pressure\n    self._add_hydrostatic_scenario(scenario_counter, ref_p)\n\n    #Increment scenario counter\n    scenario_counter += 1\n\n    #Iterate over input scenarios\n    if n_scenarios &gt; 0:\n        scenario_counter = self._add_input_scenarios(scenario_counter, ref_p)\n\n    #Iterate over maximum pressure scenarios\n    if not self.max_pressure_pos is None:\n        self._add_max_pressure_scenarios(scenario_counter, MAX_PRESSURE_NAME)</code></pre>"},{"location":"code_references/well_class/well_pressure/#src.WellClass.libs.well_pressure.pressure.Pressure.compute_barrier_leakage","title":"<code>compute_barrier_leakage(well: Well, barrier_name: str) -&gt; pd.DataFrame</code>","text":"<p>Compute leakage rate from the given barrier</p> <p>Parameters:</p> <ul> <li> <code>well</code>               (<code>Well</code>)           \u2013            <p>well information</p> </li> <li> <code>barrier_name</code>               (<code>str</code>)           \u2013            <p>barrier to check the leakage rate</p> </li> </ul> Source code in <code>src/WellClass/libs/well_pressure/pressure.py</code> <pre><code>def compute_barrier_leakage(self, well: Well, barrier_name: str) -&gt; pd.DataFrame:\n    \"\"\" Compute leakage rate from the given barrier\n\n        Args:\n            well (Well): well information\n            barrier_name (str): barrier to check the leakage rate\n    \"\"\"\n    if well.inventory['barriers']:\n        # for convenience\n        barrier_perm = well.barrier_perm\n\n        # barrier geometries\n        barrier_props = well.compute_barrier_props(barrier_name)\n\n        # Estimate CO2 leakage in [tons/day] after a trancient period\n        barrier_leakage = compute_barrier_leakage(barrier_perm, self.pressure_scenarios, self.pressure_CO2, barrier_props)\n\n        return barrier_leakage\n\n    else:\n        print(f'No barriers declared in well {well.header[\"well_name\"]}')</code></pre>"}]}